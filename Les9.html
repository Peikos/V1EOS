<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Embedded &amp; Operating Systems 9">
  <title>Virtualisation</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Virtualisation</h1>
  <p class="author">Embedded &amp; Operating Systems 9</p>
</section>

<section id="introductie" class="slide level2">
<h2>Introductie</h2>
<!--
-->
<aside class="notes">
<p>De vorige les hebben we al een beetje kennis gemaakt met virtualisatie, in de vorm van de JVM en .NET virtual machine. In deze les kijken we verder naar virtuele machines, en hoe deze in het OS geïntergreerd kunnen zijn. De overkoepelende eigenchap van virtual machines is dat deze een systeem emuleren in software. Dit kan een PC zijn die een andere PC in een venster draait (om meerdere OSs tegelijk te draaien), een ander type hardware (emulatie) of een type machine dat fysiek niet bestaat.</p>
</aside>
</section>
<section id="bytecode-virtual-machines" class="slide level2">
<h2>Bytecode Virtual Machines</h2>
<!--
De JVM en .NET virtual machines behoren tot de laatste categorie: de machine die gevirtualiseerd wordt is niet een daadwerkelijke fysieke machine, maar een construct dat specifiek als virtuele machine ontworpen is. De machine dient als interpreter voor code die al gedeeltelijk gecompileerd is, met als voornaamste doel portability: als de VM op een systeem draait, kan alle software die op de VM draait gebruikt worden. 
Ook WebAssembly, een low-level assembly achtige subset van JavaScript, kan als een bytecode virtual machine beschouwd worden. Code in C++ (of welke andere taal dan ook, zo lang er een compiler bestaat) kan tot WebAssembly gecompileerd worden, waarna een browser kan dienen als virtual machine / JIT compiler.
Sommige talen nemen de intergratie met de bijbehorende VM nog een stapje verder. Pharo, een dialect van SmallTalk, wordt zowel ontwikkeld als uitgevoerd binnen de virtuele machine. De VM ondersteunt een grafische interface, waarbinnen code (zowel van de gebruiker als van het systeem zelf) geinspecteerd, aangepast en uitgevoerd kan worden.
-->
<aside class="notes">

</aside>
</section>
<section id="hardware-virtualisation" class="slide level2">
<h2>Hardware Virtualisation</h2>
<!--
De meest klassieke vorm van virtual machines wordt doorgaans als _platform virtualisation_ of _hardware virtualisation_ aangeduid. De computer draait een besturingssysteem, met daarbinnen een applicatie, de _hypervisor_, die een fysieke computer nabootst. Vaak is dit een beperkte kopie van de _host computer_, de computer waarop de software draait. De _guest computer_ kan een kopie van hetzelfde besturingssysteem draaien, bijvoorbeeld om een afgeschermde omgeving te leveren, of een ander OS draaien, bijvoorbeeld Linux op Windows of vice-versa.
Als de architectuur van de _guest computer_ afwijkt van die van de _host computer_ wordt dit doorgaans _emuleren_ genoemd. Een _emulator_ kan bijvoorbeeld een spelcomputer of mobiel platform nabootsen, zodat software hiervoor op de computer ontwikkeld en direct getest kan worden. Emulatoren worden ook ingezet om software voor verouderde hardware te kunnen blijven gebruiken.
-->
<aside class="notes">

</aside>
</section>
<section id="bare-metal-hypervisors" class="slide level2">
<h2>Bare-Metal Hypervisors</h2>
<!--
Hoewel de meeste consumenten-hypervisors als applicatie binnen een OS draaien (zogenaamde _hosted hypervisors_, waarbij het OS de _host_ levert) is dit niet noodzakelijk. Bij bare-metal hypervisors draait de hypervisor direct op de hardware — in plaats van een OS. Binnen de hypervisor kunnen dan verschillende besturingssytemen draaien.
Bij een hosted hypervisor is vaak sprake van een flinke performance-hit voor de guest OSs: de software binnen de guest is erg ver van de hardware verwijderd, waardoor er veel overhead is en vertaling plaatsvindt.
Bij bare-metal hypervisors wordt is dit niet (of nauwelijks) het geval. Alle OSs die binnen een bare-metal hypervisor draaien zijn gelijkwaardig, en draaien zo dicht mogelijk op de hardware als mogelijk (met alleen een minimale hypervisor ertussen).
-->
<aside class="notes">

</aside>
</section>
<section id="containers" class="slide level2">
<h2>Containers</h2>
<!--
Bij hypervisor-virtualisatie wordt een compleet hardware-systeem gevirtualiseerd. Virtualisatie kan daarnaast ook op OS-level plaatsvinden. Het systeem draait dan een enkele kernel, maar hierop draaien meerdere geisoleerde userspaces: _containers_. Binnen Linux is Docker het meest gebruikte platform voor het draaien van containers.
Voor een proces binnen een container lijkt het alsof deze zich op een normale computer bevindt. Wat het proces van het systeem kan zien is echter beperkt tot de inhoud van de container.
Meestal wordt een container voor een enkel proces (server, compiler, etc.) gebruikt, dat binnen de container compleet geïsoleerd draait. De verschillende containers werken allemaal op dezelfde kernel, maar kunnen op userspace-niveau flink van elkaar afwijken. Het is prima mogelijk op een Ubuntu syteem een container te draaien die gebaseerd is op Fedora, of welke andere distro dan ook, zodat voor iedere applicatie de beste omgeving kan worden gekozen. Doorgaans wordt hiervoor een zo licht mogelijke disto gebruikt, zoals Alpine Linux. Daarnaast bestaan er distributies die speciaal ontwikkeld zijn om containers te hosten, waarbij de host zo licht mogelijk wordt gehouden en alle software binnen containers draait. Voorbeelden hiervan zijn CoreOS en RancherOS.
-->
<aside class="notes">

</aside>
</section>
<section id="wat-hebben-we-deze-les-geleerd" class="slide level2">
<h2>Wat hebben we deze les geleerd?</h2>
<ul>
<li>Bytecode-gebaseerde virtual machines</li>
<li>Hosted en bare-metal hypervisors</li>
<li>OS-level virtualisation met containers</li>
</ul>
</section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
