<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Embedded &amp; Operating Systems 9">
  <title>Virtualisation en Microcontrollers</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Virtualisation en Microcontrollers</h1>
  <p class="author">Embedded &amp; Operating Systems 9</p>
</section>

<section id="introductie" class="slide level2">
<h2>Introductie</h2>
<!--
-->
<aside class="notes">
<p>De vorige les hebben we al een beetje kennis gemaakt met virtualisatie, in de vorm van de JVM en .NET virtual machine. In deze les kijken we verder naar virtuele machines, en hoe deze in het OS geïntergreerd kunnen zijn. De overkoepelende eigenchap van virtual machines is dat deze een systeem emuleren in software. Dit kan een PC zijn die een andere PC in een venster draait (om meerdere OSs tegelijk te draaien), een ander type hardware (emulatie) of een type machine dat fysiek niet bestaat. Daarnaast zullen we kijken naar microcontrollers: embedded systemen zonder OS. Het aansturen van de hardware is grotendeels hetzelfde, maar in dit geval combineert de embedded software deze taak met de daadwerkelijke functionaliteit die het device moet leveren.</p>
</aside>
</section>
<section id="bytecode-virtual-machines" class="slide level2">
<h2>Bytecode Virtual Machines</h2>
<!--
- Herhaling vorige les, bytecode gebaseerde talen = virtuele machine
- Webassembly: asembly in javascript met browser als VM
- Pharo als voorbeeld bytecode VM met geavanceerde interface
-->
<aside class="notes">
<p>De JVM en .NET virtual machines behoren tot de laatste categorie: de machine die gevirtualiseerd wordt is niet een daadwerkelijke fysieke machine, maar een construct dat specifiek als virtuele machine ontworpen is. De machine dient als interpreter voor code die al gedeeltelijk gecompileerd is, met als voornaamste doel portability: als de VM op een systeem draait, kan alle software die op de VM draait gebruikt worden. Ook WebAssembly, een low-level assembly achtige subset van JavaScript, kan als een bytecode virtual machine beschouwd worden. Code in C++ (of welke andere taal dan ook, zo lang er een compiler bestaat) kan tot WebAssembly gecompileerd worden, waarna een browser kan dienen als virtual machine / JIT compiler. Sommige talen nemen de intergratie met de bijbehorende VM nog een stapje verder. Pharo, een dialect van SmallTalk, wordt zowel ontwikkeld als uitgevoerd binnen de virtuele machine. De VM ondersteunt een grafische interface, waarbinnen code (zowel van de gebruiker als van het systeem zelf) geinspecteerd, aangepast en uitgevoerd kan worden.</p>
</aside>
<p><img data-src="images/java-jit.png" /></p>
</section>
<section id="hardware-virtualisation" class="slide level2">
<h2>Hardware Virtualisation</h2>
<!--
- VM simuleert hele fysieke computer; OS draait in VM, software draait binnen OS en weet niets van virtualisatie.
- Zelfde OS of ander OS
- Emulator voor andere virtuele processorarchitectuur
-->
<aside class="notes">
<p>De meest klassieke vorm van virtual machines wordt doorgaans als <em>platform virtualisation</em> of <em>hardware virtualisation</em> aangeduid. De computer draait een besturingssysteem, met daarbinnen een applicatie, de <em>hypervisor</em>, die een fysieke computer nabootst. Vaak is dit een beperkte kopie van de <em>host computer</em>, de computer waarop de software draait. De <em>guest computer</em> kan een kopie van hetzelfde besturingssysteem draaien, bijvoorbeeld om een afgeschermde omgeving te leveren, of een ander OS draaien, bijvoorbeeld Linux op Windows of vice-versa. Als de architectuur van de <em>guest computer</em> afwijkt van die van de <em>host computer</em> wordt dit doorgaans <em>emuleren</em> genoemd. Een <em>emulator</em> kan bijvoorbeeld een spelcomputer of mobiel platform nabootsen, zodat software hiervoor op de computer ontwikkeld en direct getest kan worden. Emulatoren worden ook ingezet om software voor verouderde hardware te kunnen blijven gebruiken.</p>
</aside>
<p><img data-src="images/virtualisation.png" style="width:70.0%" /></p>
</section>
<section id="bare-metal-hypervisors" class="slide level2">
<h2>Bare-Metal Hypervisors</h2>
<!--
-->
<aside class="notes">
<p>Hoewel de meeste consumenten-hypervisors als applicatie binnen een OS draaien (zogenaamde <em>hosted hypervisors</em>, waarbij het OS de <em>host</em> levert) is dit niet noodzakelijk. Bij bare-metal hypervisors draait de hypervisor direct op de hardware — in plaats van een OS. Binnen de hypervisor kunnen dan verschillende besturingssytemen draaien. Bij een hosted hypervisor is vaak sprake van een flinke performance-hit voor de guest OSs: de software binnen de guest is erg ver van de hardware verwijderd, waardoor er veel overhead is en vertaling plaatsvindt. Bij bare-metal hypervisors wordt is dit niet (of nauwelijks) het geval. Alle OSs die binnen een bare-metal hypervisor draaien zijn gelijkwaardig, en draaien zo dicht mogelijk op de hardware als mogelijk (met alleen een minimale hypervisor ertussen).</p>
</aside>
<p><img data-src="images/bare-metal.png" style="width:50.0%" /></p>
</section>
<section id="containers" class="slide level2">
<h2>Containers</h2>
<!--
-->
<aside class="notes">
<p>Bij hypervisor-virtualisatie wordt een compleet hardware-systeem gevirtualiseerd. Virtualisatie kan daarnaast ook op OS-level plaatsvinden. Het systeem draait dan een enkele kernel, maar hierop draaien meerdere geisoleerde userspaces: <em>containers</em>. Binnen Linux is Docker het meest gebruikte platform voor het draaien van containers. Voor een proces binnen een container lijkt het alsof deze zich op een normale computer bevindt. Wat het proces van het systeem kan zien is echter beperkt tot de inhoud van de container. Meestal wordt een container voor een enkel proces (server, compiler, etc.) gebruikt, dat binnen de container compleet geïsoleerd draait. De verschillende containers werken allemaal op dezelfde kernel, maar kunnen op userspace-niveau flink van elkaar afwijken. Het is prima mogelijk op een Ubuntu syteem een container te draaien die gebaseerd is op Fedora, of welke andere distro dan ook, zodat voor iedere applicatie de beste omgeving kan worden gekozen. Doorgaans wordt hiervoor een zo licht mogelijke disto gebruikt, zoals Alpine Linux. Daarnaast bestaan er distributies die speciaal ontwikkeld zijn om containers te hosten, waarbij de host zo licht mogelijk wordt gehouden en alle software binnen containers draait. Voorbeelden hiervan zijn CoreOS en RancherOS.</p>
</aside>
<p><img data-src="images/docker.png" style="width:50.0%" /></p>
</section>
<section id="microcontrollers" class="slide level2">
<h2>Microcontrollers</h2>
<!--
-->
<aside class="notes">
<p>Hoewel de focus tot nu toe gelegen heeft op OSs en applicaties die op een OS draaien (hosted applications), ligt de focus van de TI-er vaak op een ander domein: de microcontroller. Hier wordt net als bij (het programmeren van) een OS bare-metal gewerkt. De software heeft directe toegang tot de hardware, en er zijn niet zomaar abstracties aanwezig om het leven van de ontwikkelaar te vereenvoudigen. In de volgende slides zullen we zien hoe het programmeren van een microcontroller verschilt ten opzichte van OS development en het schrijven van hosted applicaties.</p>
</aside>
</section>
<section id="development-pipeline" class="slide level2">
<h2>Development Pipeline</h2>
<!--
-->
<aside class="notes">
<p>Het eerste verschil is de manier waarop de development pipeline in elkaar steekt. Omdat een bare-metal microcontroller geen OS heeft, draait hier geen tekst-editor of compiler op waardoor deze niet direct geprogrammeerd kan worden. In plaats hiervan moeten we gebruik maken van een development-systeem om de code te schrijven, en deze met een cross-compiler omzetten naar een binary voor de micro-controller. Dit binary-bestand kan dan in de microcontroller worden ingeladen door deze naar het EEPROM of Flash-geheugen te schrijven.</p>
</aside>
</section>
<section id="geheugengebruik-van-applicaties-op-een-os" class="slide level2">
<h2>Geheugengebruik van applicaties op een OS</h2>
<!--
-->
<aside class="notes">
<p>Een andere manier waarop een bare-metal microcontroller van een computer met OS verschilt is de manier waarop het geheugen wordt gebruikt. De computers waar we tot zover naar hebben gekeken maken gebruik van een combinatie van RAM geheugen en persistent storage (harde schijf of SSD). Alle code en bijbehorende data, zowel van het OS als van de applicaties, is ergens op de persistent storage te vinden. Bij het booten wordt de OS code hiervandaan naar het RAM gekopieerd, en bij het starten van een programma komt ook deze code ergens in het RAM te staan. Alle memory-segmenten die we hebben gezien binnen een proces (of het OS) zijn in de binary file aanwezig en worden 1-op-1 in het geheugen overgenomen.</p>
</aside>
</section>
<section id="geheugengebruik-bij-microcontrollers" class="slide level2">
<h2>Geheugengebruik bij microcontrollers</h2>
<!--
-->
<aside class="notes">
<p>Bij een bare-metal microcontroller werkt dit anders: alle code en data is bij het flashen in het ROM geheugen opgeslagen. Bij het uitvoeren wordt dit niet naar RAM geheugen verplaatst, maar wordt alles zoveel mogelijk direct uit het ROM gelezen. Variabele data, dus data die kan veranderen, heeft een initiële waarde in het ROM staan, maar wordt naar het RAM gekopieerd om de data aan te kunnen passen.</p>
</aside>
</section>
<section id="peripherals" class="slide level2">
<h2>Peripherals</h2>
<!--
-->
<aside class="notes">
<p>Ook is het bij een bare-metal microcontroller niet mogelijk op de BIOS te vertrouwen om bepaalde taken uit te voeren: de BIOS is op zichzelf al een complex stuk software (of beter gezegd, firmware) dat niet op een standaard microcontroller aanwezig zal zijn. Meer nog dan bij het schrijven van een OS worden peripherals (randapparatuur, alles dat zich buiten de CPU en het geheugen bevindt) aangestuurd door direct naar geheugenposities te schrijven en direct uit geheugenposities te lezen: alle peripherals zijn direct in de memory map aanwezig. In code voor operating systems gebeurt dit ook wel (zoals te zien in ons C++ voorbeeld vorige week, waarbij naar een geheugenrange geschreven werd om tekst te printen), maar bij microcontrollers is dit nog meer gebruikelijk.</p>
</aside>
</section>
<section id="microcontroller-libraries" class="slide level2">
<h2>Microcontroller Libraries</h2>
<!--
-->
<aside class="notes">
<p>Hoewel bare-metal programmeren op een microcontroller een hoop meer handwerk vereist, kunnen we nog steeds gebruik maken van de eerste tool die een programmeur voor handen heeft: compositie. Door een probleem in kleinere subproblemen op te delen kan herbruikbare code gemaakt worden, die in de vorm van libraries te delen is tussen verschillende projecten. Later in de opleiding zullen jullie met Hwlib te maken krijgen: een library die op de HU ontwikkeld is om het programmeren van microcontrollers toegankelijker te maken.</p>
</aside>
</section>
<section id="library-operating-systems-en-unikernels" class="slide level2">
<h2>Library Operating Systems en Unikernels</h2>
<!--
-->
<aside class="notes">
<p>Een tussenvorm tussen een bare-metal microcontroller en een operating system is een zogenaamd Library OS. Hierbij worden de gebruikelijke diensten die een OS levert aangeboden in de vorm van libraries. Dit maakt het mogelijk complexe functies te gebruiken alsof de applicatie op een OS draait, maar in werklelijkheid is deze functionaliteit in de applicatie opgenomen. Het resultaat is een binary die zowel de applicatie-code als (de relevante delen van) de OS code bevat: een zogenaamde unikernel. Een unikernel heeft een enkele adres-ruimte, dus geen onderscheid tussen kernel-space en user-space, en kan in het geheel op microcontrollers ingezet worden. Een voorbeeld van een library OS is IncludeOS.</p>
</aside>
<p><img data-src="images/includeos.png" /></p>
</section>
<section id="wat-hebben-we-deze-les-geleerd" class="slide level2">
<h2>Wat hebben we deze les geleerd?</h2>
<ul>
<li>Bytecode-gebaseerde virtual machines</li>
<li>Hosted en bare-metal hypervisors</li>
<li>OS-level virtualisation met containers</li>
<li>Verschillen in development pipeline voor microcontrollers</li>
<li>Verschillen in geheugengebruik tussen OS en microcontrollers</li>
<li>Libraries voor microcontrollers</li>
</ul>
</section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
