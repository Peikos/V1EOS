<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <title>Embedded &amp; Operating Systems 0 — Wat is een OS?</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/hu.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">


<section id="section" class="slide level2" data-background="../Images/title_background.png">
<h2></h2>
<h1>
Wat is een OS?
</h1>
<p>
Embedded &amp; Operating Systems 0
</p>
<aside class="notes">
<p>Bij de eerste les ligt de focus op de volgende punten - Wat is een Operating System (en wat is het niet) - Wat zijn de voornaamste OSs - Waar zitten de belangrijkste verschillen tussen verschillende OSs Details over de interne werking (met name UNIX) komt in latere lessen aan bod. Het begrip SysCall wordt al wel gebruikt om het verschil tussen de OSs in te vatten.</p>
</aside>
</section>
<section id="inhoud" class="slide level2" data-background="../Images/title_background.png">
<h2>Inhoud</h2>
<ul>
<li><strong>Terugblik blok 1</strong></li>
<li>Operating Systems</li>
<li>Taken Operating System</li>
<li>Hardware-aansturing</li>
<li>Geheugenmodel van een taak</li>
</ul>
</section>
<section id="waar-waren-we-gebleven" class="slide level2">
<h2>Waar waren we gebleven?</h2>
<aside class="notes">
<p>Op de slide staat een korte terugblik op het eindresultaat van het CS gedeelte van CSN. We hebben een simpele computer, die we met een eigen assembly-dialect kunnen programmeren.</p>
</aside>
<figure>
<img data-src="../Images/CPU-io-fix-carry6.png" alt="De CPU" style="width:75.0%" /><figcaption>De CPU</figcaption>
</figure>
</section>
<section id="instructies" class="slide level2">
<h2>Instructies</h2>
<aside class="notes">
<p>Hoe programmeren we de computer? Dit doen we met machine-code / assembly, maar dit is CPU specifiek.</p>
</aside>
<div style="font-size: 12px">
<table>
<tbody>
<tr class="odd">
<td>1000 Ra Rb</td>
<td style="text-align: left;">ADD Ra Rb</td>
<td style="text-align: left;">Tel Ra bij Rb</td>
</tr>
<tr class="even">
<td>1001 Ra Rb</td>
<td style="text-align: left;">SHR Ra Rb</td>
<td style="text-align: left;">Shift Ra naar rechts</td>
</tr>
<tr class="odd">
<td>1010 Ra Rb</td>
<td style="text-align: left;">SHL Ra Rb</td>
<td style="text-align: left;">Shift Ra naar links</td>
</tr>
<tr class="even">
<td>1011 Ra Rb</td>
<td style="text-align: left;">NOT Ra Rb</td>
<td style="text-align: left;">Inverteer Ra</td>
</tr>
<tr class="odd">
<td>1100 Ra Rb</td>
<td style="text-align: left;">AND Ra Rb</td>
<td style="text-align: left;">Ra AND Rb</td>
</tr>
<tr class="even">
<td>1101 Ra Rb</td>
<td style="text-align: left;">OR Ra Rb</td>
<td style="text-align: left;">Ra OR Rb</td>
</tr>
<tr class="odd">
<td>1110 Ra Rb</td>
<td style="text-align: left;">XOR Ra Rb</td>
<td style="text-align: left;">Ra XOR Rb</td>
</tr>
<tr class="even">
<td>1111 Ra Rb</td>
<td style="text-align: left;">CMP Ra Rb</td>
<td style="text-align: left;">Vergelijk Ra en Rb</td>
</tr>
<tr class="odd">
<td>0000 Ra Rb</td>
<td style="text-align: left;">LD Ra Rb</td>
<td style="text-align: left;">Laad de byte op adres Ra in Rb</td>
</tr>
<tr class="even">
<td>0001 Ra Rb</td>
<td style="text-align: left;">ST Ra Rb</td>
<td style="text-align: left;">Sla de byte in Rb op in adres Ra</td>
</tr>
<tr class="odd">
<td>0010 00 Rb</td>
<td style="text-align: left;">DATA Rb, Addr</td>
<td style="text-align: left;">Zet de volgende byte in Rb</td>
</tr>
<tr class="even">
<td>0011 00 Rb</td>
<td style="text-align: left;">JMPR Rb</td>
<td style="text-align: left;">Spring naar adres in Rb</td>
</tr>
<tr class="odd">
<td>0100 00 00</td>
<td style="text-align: left;">JMP Addr</td>
<td style="text-align: left;">Spring naar adres in next byte</td>
</tr>
<tr class="even">
<td>0101 caez</td>
<td style="text-align: left;">JCAEZ Addr</td>
<td style="text-align: left;">Jump als flag aan is</td>
</tr>
<tr class="odd">
<td>0110 00 00</td>
<td style="text-align: left;">CLF</td>
<td style="text-align: left;">Reset alle vlaggen.</td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="python" class="slide level2">
<h2>Python</h2>
<aside class="notes">
<p>Vanaf de andere kant hebben we high-level code gezien, zoals Python. Dit werkt op meerdere systemen (architectures) en is daarnaast ook minder “langdradig”. Hoe kunnen we ervoor zorgen dat we Python-code (of andere high-level code) op onze computer kunnen draaien?</p>
</aside>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1">infile <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;input.txt&#39;</span>, <span class="st">&#39;r&#39;</span>)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">outfile <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;output.txt&#39;</span>, <span class="st">&#39;w&#39;</span>)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="cf">for</span> line <span class="kw">in</span> infile:</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    outfile.write(line)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">outfile.close()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">infile.close()</a></code></pre></div>
</section>
<section id="inhoud-1" class="slide level2" data-background="../Images/title_background.png">
<h2>Inhoud</h2>
<ul>
<li>Terugblik blok 1</li>
<li><strong>Operating Systems</strong></li>
<li>Taken Operating System</li>
<li>Hardware-aansturing</li>
<li>Geheugenmodel van een taak</li>
</ul>
</section>
<section id="het-operating-system-os" class="slide level2">
<h2>Het Operating System (OS)</h2>
<aside class="notes">
<p>Om deze twee werelden bij elkaar te brengen is een systeem nodig dat enerzijds met de specifeke hardware overweg kan, en anderzijds eenzelfde basis biedt voor software (ongeacht wat de onderliggende hardware is). Dit is het Operating System, dat als laag tussen de applicaties en de hardware zit. Zonder dit OS moet je als programmeur zelf alle details van de computer-hardware managen, waardoor je telkens weer veel (foutgevoelige) code nodig hebt om simpele taken te kunnen programmeren. Denk hierbij aan het opslaan van data, het afwisselen van meerdere taken, of het weergeven van een interface op het scherm. Software zoals een web-browser of office-suite zijn zonder de abstractie van een OS vrijwel onmogelijk te programmeren, en als het al lukt specifiek voor één systeem gemaakt. Met het OS is er een basis waar complexe software op gemaakt kan worden, en in deze cursus maken we kennis met de principes van OS-ontwikkeling — dit is waar de TI-er zich binnen ICT onderscheidt. Het OS bestaat uit twee lagen: de kernel die direct met de hardware communiceert en de rest van het OS. Het verschil zit hem in het feit dat de kernel in kernel mode draait, en de rest van het OS net als de andere software in userland. Dit is een verschil in welke instructies de CPU wel en niet mag uitvoeren; hier komen we later op terug. Voor nu heeft het OS twee raakvlakken: - De specifieke hardware, die door het OS aangestuurd wordt - Software, waarvoor het OS een generieke basis levert</p>
</aside>
<figure>
<img data-src="../Images/os-layers-1.png" alt="Basismodel Operating Systems" style="width:50.0%" /><figcaption>Basismodel Operating Systems</figcaption>
</figure>
</section>
<section id="desktop-operating-systems" class="slide level2">
<h2>Desktop Operating Systems</h2>
<aside class="notes">
<p>Waar denk je aan bij een besturingssysteem? Op de slide de grootste drie besturingssystemen voor de desktop/laptop, maar er is meer dat we als besturingssysteem zien. Op de volgende slide ook iOS en Android.</p>
</aside>
<p><img data-src="../Images/ubuntu.jpg" alt="Linux" style="width:40.0%" /> <img data-src="../Images/windows10.jpg" alt="Windows" style="width:40.0%" /> <img data-src="../Images/macosx.jpg" alt="MacOS" style="width:40.0%" /></p>
</section>
<section id="mobiele-operating-systems" class="slide level2">
<h2>Mobiele Operating Systems</h2>
<aside class="notes">
<p>Noem bij de mobiele OSs nog even dat iOS vooral een mobiele versie is van MacOS (en als Operating System dus in grote mate identiek is — de verschillen zitten hem in de aankleding, wat niet bij het OS hoort) en Android op Linux gebaseerd is. Wijs de studenten ook op dat hoewel het OS aan de bovenkant (vanuit de software gezien) hetzelfde is voor iOS/MacOS en Android/Linux, de systemen wel op heel andere hardware draaien.</p>
</aside>
<figure>
<img data-src="../Images/mobile.jpg" alt="Smartphone OS: iOS en Android" style="width:60.0%" /><figcaption>Smartphone OS: iOS en Android</figcaption>
</figure>
</section>
<section id="de-gui" class="slide level2">
<h2><del>De GUI</del></h2>
<aside class="notes">
<p>Belangrijk punt (ook al even naar gehint bij de vorige slide) is dat de grafische omgeving niet deel van het besturingssysteem is, maar een applicatie die daarbovenop draait. Bij Linux is dit verschil duidelijker (je kan zelf kiezen welke interface je gebruikt), terwijl de interface van Windows en Mac vrijwel onlosmakelijk met het besturingssysteem geassocieerd is. Het feit dat je de software als pakket koopt en het geheel in de marketing een besturinssysteem genoemd wordt, betekent <strong>niet</strong> dat deze schil technisch deel van het OS is.</p>
</aside>
<figure>
<img data-src="../Images/terminal.png" alt="Niet per sé een Grafische User Interface (GUI)" style="width:50.0%" /><figcaption>Niet per sé een Grafische User Interface (GUI)</figcaption>
</figure>
</section>
<section id="inhoud-2" class="slide level2" data-background="../Images/title_background.png">
<h2>Inhoud</h2>
<ul>
<li>Terugblik blok 1</li>
<li>Operating Systems</li>
<li><strong>Taken Operating System</strong></li>
<li>Hardware-aansturing</li>
<li>Geheugenmodel van een taak</li>
</ul>
</section>
<section id="taken-operating-system" class="slide level2">
<h2>Taken Operating System</h2>
<ul>
<li>Abstractie van de hardware t.b.v. user processes</li>
<li>Aansturen randapparatuur / IO</li>
<li>Processen laden en managen / scheduling</li>
<li>Bewaken system resources (e.g. memory, CPU-tijd)</li>
<li>Leveren van een filesystem</li>
</ul>
</section>
<section id="abstractie" class="slide level2">
<h2>Abstractie</h2>
<aside class="notes">
<p>De meerwaarde van het OS is dat je, in plaats van dat je software specifiek schrijft voor een bepaalde hardware-configuratie, schrijft voor een generiek OS. Nog steeds andere code nodig voor e.g. Linux vs Windows, maar dit betekent 1-3 platforms ondersteunen i.p.v. elke mogelijke hardwarecombinatie. Verdere abstractie is mogelijk (in Python maakt het nauwelijks uit of je voor Windows of Linux of Mac programmeert) maar dat is weer een laag bovenop het OS.</p>
</aside>
<ul>
<li>OS levert abstractie van de hardware</li>
<li>Software praat niet direct tegen CPU en devices maar tegen OS</li>
<li>Software gebonden aan OS</li>
</ul>
</section>
<section id="bare-metal" class="slide level2">
<h2>Bare Metal</h2>
<aside class="notes">
<p>Niet alle computersystemen gebruiken een OS. Een systeem dat zelf direct met de hardware communiceert noemen we bare metal. Een operating system en bare metal-software hebben beide te maken met de directe hardware, en gebruiken veelal dezelfde principes om hiermee om te gaan: de principes waar je in de rest van deze cursus kennis mee zal maken. Het voornaamste verschil is dat het OS zelf geen taak heeft, behalve het ondersteunen van de applicaties die erop gedraaid worden. Bare-metal software heeft wel een eigen taak, en is dus te beschouwen als de combinatie van een heel simpel OS en een enkele applicatie in één. Meestal hebben we het over microcontrollers als we het over bare-metal systemen hebben die zelf geen OS zijn. Natuurlijk zijn er meer verschillen waar je rekening mee moet houden als je bare-metal (aan OSs of microcontrollers) programmeert, hier zullen we later in de cursus bij stilstaan.</p>
</aside>
<ul>
<li>Een systeem zonder OS heet een microcontroller</li>
<li>Voor specifieke taak geprogrammeerd</li>
<li>Zelfde principes gaan op, maar specifiek toegepast i.p.v. generiek</li>
</ul>
</section>
<section id="inhoud-3" class="slide level2" data-background="../Images/title_background.png">
<h2>Inhoud</h2>
<ul>
<li>Terugblik blok 1</li>
<li>Operating Systems</li>
<li>Taken Operating System</li>
<li><strong>Hardware-aansturing</strong></li>
<li>Geheugenmodel van een taak</li>
</ul>
</section>
<section id="user-mode-vs-kernel-mode" class="slide level2">
<h2>User mode vs Kernel Mode</h2>
<aside class="notes">
<p>Een processor draait in verschillende modes, elk met eigen priviliges. We onderscheiden hier twee modes of “privilege levels”: de kernel mode met alle privileges, en de user mode die niet direct tegen de hardware kan praten, maar van het OS afhankelijk is. User mode processen hebben daarmee ook geen directe toegang tot het geheugen. Als ze iets uit het geheugen willen halen moeten ze dit doen via het OS, dat daardoor kan voorkomen dat user-mode processen buiten hun eigen toegewezen geheugen lezen of schrijven. OS (of specifieker de kernel) draait in kernel mode, en kan wel overal bij. Dit is van belang omdat een general-purpose computer niet zonder meer alle software kan vertrouwen. Een kwaadaardig programma kan bijvoorbeeld proberen gegevens van andere processen te lezen om achter wachtwoorden of bankgegevens te komen, of zichzelf in het opstartproces installeren. Dankzij het gebruik van privilege-levels kunnen dit soort activiteiten niet zonder meewerking van het OS plaatsvinden. De huidige mode waarin de CPU draait is opgeslagen in het Code-Segment (CS) register binnen de CPU. Dit register houdt bij in welk geheugen-segment de code staat die uitgevoerd wordt, waarbij de laatste twee bits het privilige level aanduiden. Alleen code die op de juiste plaats in het geheugen staat kan in kernel mode worden uitgevoerd, en het OS zorgt er tijdens het opstarten voor dat de kernel-mode segmenten overeen komen met waar de OS code te vinden is. De naam “Kernel mode” houdt verband met de term “kernel”, waar de kern van het besturingssysteem mee wordt aangeduid.</p>
</aside>
<ul>
<li>Processor draait in 2 (of meer) modes
<ul>
<li>Kernel mode</li>
<li>User mode</li>
</ul></li>
</ul>
</section>
<section id="kernel-models" class="slide level2">
<h2>Kernel Models</h2>
<aside class="notes">
<p>Daarmee meteen nog een belangrijk onderscheid tussen verschillende kernels: monolitisch vs microkernels. Monolitische kernels draaien alle traditionele OS taken in kernel mode, en zijn dus als een monoliet (grote steen uit één stuk). Microkernels draaien alleen het broodnodige in de kernel, en besteden alle het andere zoveel mogelijk uit aan user mode processen. Microkernels zouden veiliger zijn (al is dit een open debat) maar betalen hier wel voor met lagere peformance door meer te moeten switchen tussen beide modes.</p>
</aside>
<ul>
<li>Monolithic (e.g. Linux, Windows)
<ul>
<li>Alle taken OS in kernel mode</li>
</ul></li>
<li>Microkernel
<ul>
<li>Bare minimum</li>
<li>Zoveel mogelijk in user mode</li>
</ul></li>
</ul>
</section>
<section id="syscalls" class="slide level2">
<h2>SysCalls</h2>
<aside class="notes">
<p>Als een applicatie iets gedaan wil krijgen, heeft het voor veel taken niet de juiste privileges. Het is daarmee dus op het OS aangewezen. Een programma kan (en zal, met grote regelmaat) de kernel vragen om bijvoorbeeld (file) IO te doen, andere applicaties te starten, extra geheugen te reserveren, etc. Dit gebeurt door middel van system calls (SysCalls). Dit zijn functies die vanuit de software worden aangeroepen, en de processor onderbreken. Deze zal speciale code van het OS inladen, die wel in kernel mode mag draaien. De OS-code voert het verzoek uit, en schakelt daarna weer terug naar user-mode. Hierna kan de software verder gaan waar het is gebleven. Iedere applicatie (of specifiek ieder proces, maar hier komen we later op terug) heeft een eigen kopie van de SysCall table met de nummers en adressen van de system calls. Dit zorgt ervoor dat SysCalls zo snel mogelijk kunnen worden afgehandeld.</p>
</aside>
<ul>
<li>Functies die OS vragen om iets te doen</li>
<li>Onderbreken user mode software</li>
<li>Switch naar kernel mode, OS handelt verzoek af</li>
<li>Iedere SysCall heeft een nummer</li>
</ul>
</section>
<section id="syscalls-1" class="slide level2">
<h2>SysCalls</h2>
<aside class="notes">
<p>De SysCalls in een Linux systeem zijn heel anders dan die op Windows. Dit heeft ermee te maken dat de besturingssystemen een heel andere filosofie hanteren. In Linux is het bijvoorbeeld gebruikelijk om meerdere kleine (command-line) programma’s aan elkaar te koppelen, en hier zijn dan ook speciale SysCalls voor. Windows heeft deze filosofische achtergrond niet (maar werkt vaak met grotere programma’s die vele taken kunnen vervullen), waardoor deze SysCalls in Windows lange tijd niet aanwezig waren (inmiddels is dit concept overigens ook door Windows geleend). De meeste SysCalls bieden functionaliteit die in ieder OS gebruikt wordt, maar werken per verschillend OS net even anders. Dit is de reden dat Windows-software niet zonder meer op Linux werkt (en vice-versa). POSIX en SUS zijn standaarden waar Unix-achtige systemen (en in het geval van POSIX zelfs recente Windows versies) aan voldoen, om het makkelijker te maken software op meerdere platforms te laten draaien.</p>
</aside>
<ul>
<li>Ieder OS heeft eigen set SysCalls
<ul>
<li>eigen abstracte model computer</li>
<li>wel of niet extra verantwoordelijkheden</li>
</ul></li>
<li>Portable Operating System Interface (POSIX)</li>
<li>Single UNIX Specification (SUS)</li>
</ul>
</section>
<section id="inhoud-4" class="slide level2" data-background="../Images/title_background.png">
<h2>Inhoud</h2>
<ul>
<li>Terugblik blok 1</li>
<li>Operating Systems</li>
<li>Taken Operating System</li>
<li>Hardware-aansturing</li>
<li><strong>Geheugenmodel van een taak</strong></li>
</ul>
</section>
<section id="een-enkele-taak" class="slide level2">
<h2>Een enkele taak</h2>
<aside class="notes">
<p>Hoewel we het inmiddels een paar keer over processen hebben gehad, leggen we voor nu de nadruk nog even op een computer met een enkele taak. Later zullen we zien hoe een computer meerdere processen kan afwisselen (of met meerdere cores, tegelijk kan draaien). Het geheugen is opgedeeld in een aantal segmenten. De eerste sectie is Text en bevat de instructies van het proces. Dit gedeelte van het geheugen is na het inladen van het proces read-only: als alle code is geladen mag deze in het kader van de veiligheid niet meer veranderd worden. Na de instructies volgen de Data en BSS segmenten. Data bevat alle globale en statische variabelen met een initiele waarde. Deze worden buiten functies gedefinieerd of zijn als static (onveranderbaar) gemarkeerd. BSS (historisch: Block Started by Symbol) bevat de statische variabelen die wel defined, maar niet geïnitialiseerd zijn. Na de BSS volgen de heap en de stack, die in de volgende slides besproken worden. Beide kunnen hun formaat dynamisch aanpassen. De stack en heap beginnen leeg en groeien naar elkaar toe. Tot slot hebben we een stuk kernel space; deze bevat de code van de SysCalls en een index: een tabel met voor elke SysCall het nummer van de call en het geheugenadres waar de bijbehorende code te vinden is. Doorgaans hebben SysCalls ook een naam, maar deze wordt door de computer intern niet gebruikt. Bij het gebruik van een high-level programmeertaal zoals Python heb je als programmeur vaak geen directe invloed op wat waar in het geheugen komt: dit wordt door de Python-interpreter gemanaged.</p>
</aside>
<figure>
<img data-src="../Images/Process.png" alt="Geheugenmodel Proces" style="width:30.0%" /><figcaption>Geheugenmodel Proces</figcaption>
</figure>
</section>
<section id="intermezzo-stacks" class="slide level2">
<h2>Intermezzo: Stacks</h2>
<aside class="notes">
<p>Eerst zullen we even inzoomen op de Stack, en om deze te begrijpen moeten we eerst weten wat <strong>een</strong> stack is. Een stack (stapel) is een datastructuur waar dynamisch informatie aan toegevoegd of uitgehaald kan worden. De stack werkt volgens het <strong>Last in, first out</strong> principe, en wordt daarom ook wel de LIFO genoemd. De stack begint leeg, waarna hier data aan kan worden toegevoegd. Nieuwe data wordt bovenop de stack gezet (dit heet een <strong>push</strong>), en alleen het bovenste element van de stack is zichtbaar. Als het bovenste element gelezen wordt, wordt het meteen van de stack verwijderd (dit een heet <strong>pop</strong>).</p>
</aside>
<figure>
<img data-src="../Images/Stack%20Structure.png" alt="Stack (LIFO)" style="width:100.0%" /><figcaption>Stack (LIFO)</figcaption>
</figure>
</section>
<section id="de-stack" class="slide level2" data-transition="none">
<h2>De Stack</h2>
<aside class="notes">
<p>Ook in het geheugen wordt gebruik gemaakt van een stack. De stack heeft als voordeel dat je altijd de meest recente informatie bovenaan hebt. De stack wordt gebruikt om <em>function calls</em> mogelijk te maken: het moment dat een functie wordt aangeroepen. Op het moment dat dit gebeurt wordt er een nieuw stuk van het geheugen uitgevoerd (dus niet simpelweg de volgende instructie). Dit betekent dat de oude variabelen even niet meer toegankelijk moeten zijn, en dat daar mogelijk nieuwe variabelen voor in de plaats komen. Ook moet bekend zijn waar de software gebleven was, zodat die nadat de functie beëindigd is weer op de juiste plek verder kan. Als de functie wordt aangeroepen, wordt een frame aangemaakt. Dit frame bevat de parameters van de functieaanroep, het adres van waaraf de functie werd aangeroepen (return address) en het formaat van het frame (zodat bekend is welke bytes per <em>pop</em> gelezen moeten worden). Hierna kan met behulp van een <code>JUMP</code>-instructie (bekend van CSN) naar de functie-instructies gesprongen worden. Als een functiecall klaar is dan keert de computer terug naar de instructie direct na de functieaanroep. Deze is te vinden doordat het return adres in het frame op de stack staat opgeslagen. Zodra de computer het return adres nodig heeft wordt het frame gepopt, en wordt de stack meteen een frame kleiner.</p>
</aside>
<div class="columns">
<div class="column" style="width:60%;">
<figure>
<img data-src="../Images/Memory%20Stack%20A.png" alt="De Stack" style="width:100.0%" /><figcaption>De Stack</figcaption>
</figure>
</div><div class="column" style="width:40%;">
<p><br />
</p>
<h4 id="frame-per-function-call">Frame per function call</h4>
<ul>
<li>Lokale variabelen</li>
<li>Return address</li>
<li>Framegrootte</li>
</ul>
</div>
</div>
</section>
<section id="de-stack-1" class="slide level2" data-transition="none">
<h2>De Stack</h2>
<aside class="notes">
<p>Ook in het geheugen wordt gebruik gemaakt van een stack. De stack heeft als voordeel dat je altijd de meest recente informatie bovenaan hebt. De stack wordt gebruikt om <em>function calls</em> mogelijk te maken: het moment dat een functie wordt aangeroepen. Op het moment dat dit gebeurt wordt er een nieuw stuk van het geheugen uitgevoerd (dus niet simpelweg de volgende instructie). Dit betekent dat de oude variabelen even niet meer toegankelijk moeten zijn, en dat daar mogelijk nieuwe variabelen voor in de plaats komen. Ook moet bekend zijn waar de software gebleven was, zodat die nadat de functie beëindigd is weer op de juiste plek verder kan. Als de functie wordt aangeroepen, wordt een frame aangemaakt. Dit frame bevat de parameters van de functieaanroep, het adres van waaraf de functie werd aangeroepen (return address) en het formaat van het frame (zodat bekend is welke bytes per <em>pop</em> gelezen moeten worden). Hierna kan met behulp van een <code>JUMP</code>-instructie (bekend van CSN) naar de functie-instructies gesprongen worden. Als een functiecall klaar is dan keert de computer terug naar de instructie direct na de functieaanroep. Deze is te vinden doordat het return adres in het frame op de stack staat opgeslagen. Zodra de computer het return adres nodig heeft wordt het frame gepopt, en wordt de stack meteen een frame kleiner.</p>
</aside>
<div class="columns">
<div class="column" style="width:60%;">
<figure>
<img data-src="../Images/Memory%20Stack%20B.png" alt="De Stack" style="width:100.0%" /><figcaption>De Stack</figcaption>
</figure>
</div><div class="column" style="width:40%;">
<p><br />
</p>
<h4 id="function-call-of-syscall">Function call of syscall</h4>
<ul>
<li>Push nieuw frame</li>
<li>Bewaar PC</li>
<li>Bewaar variabelen</li>
</ul>
</div>
</div>
</section>
<section id="de-stack-2" class="slide level2" data-transition="none">
<h2>De Stack</h2>
<aside class="notes">
<p>Ook in het geheugen wordt gebruik gemaakt van een stack. De stack heeft als voordeel dat je altijd de meest recente informatie bovenaan hebt. De stack wordt gebruikt om <em>function calls</em> mogelijk te maken: het moment dat een functie wordt aangeroepen. Op het moment dat dit gebeurt wordt er een nieuw stuk van het geheugen uitgevoerd (dus niet simpelweg de volgende instructie). Dit betekent dat de oude variabelen even niet meer toegankelijk moeten zijn, en dat daar mogelijk nieuwe variabelen voor in de plaats komen. Ook moet bekend zijn waar de software gebleven was, zodat die nadat de functie beëindigd is weer op de juiste plek verder kan. Als de functie wordt aangeroepen, wordt een frame aangemaakt. Dit frame bevat de parameters van de functieaanroep, het adres van waaraf de functie werd aangeroepen (return address) en het formaat van het frame (zodat bekend is welke bytes per <em>pop</em> gelezen moeten worden). Hierna kan met behulp van een <code>JUMP</code>-instructie (bekend van CSN) naar de functie-instructies gesprongen worden. Als een functiecall klaar is dan keert de computer terug naar de instructie direct na de functieaanroep. Deze is te vinden doordat het return adres in het frame op de stack staat opgeslagen. Zodra de computer het return adres nodig heeft wordt het frame gepopt, en wordt de stack meteen een frame kleiner.</p>
</aside>
<div class="columns">
<div class="column" style="width:60%;">
<figure>
<img data-src="../Images/Memory%20Stack%20C.png" alt="De Stack" style="width:100.0%" /><figcaption>De Stack</figcaption>
</figure>
</div><div class="column" style="width:40%;">
<p><br />
</p>
<h4 id="return">Return</h4>
<ul>
<li>Zet variabelen terug</li>
<li>Reset PC</li>
<li>Pas SP aan</li>
</ul>
</div>
</div>
</section>
<section id="section-1" class="slide level2">
<h2></h2>
<aside class="notes">
<p>De stack heeft een maximale grootte. Bij simpele systemen kan dit komen door een beperkte hoeveelheid geheugen, in complexere systemen met meerdere processen is er een maximum vastgesteld. Als dit maximum bereikt wordt, spreken we van een stack overflow, en wordt de executie van het programma onderbroken (met andere woorden: een crash!). Het maximumformaat van de stack is doorgaans vrij groot, een stack overflow wordt dan ook meestal door een programmeerfout veroorzaakt. Het meest simepele voorbeeld is een functie die zichzelf herhaaldelijk aanroept (recursie). Recursie is in principe geen probleem (en in sommige gevallen zelfs de meest nette oplossing) maar als een functie altijd zichzelf aan blijft roepen (en niet na een beperkt aantal keren returnt) dan hebben we een oneindige loop waarbij de stack snel volgezet wordt. Bij een beperktere recursie wordt ook een stack opgebouwd, maar op een gegeven moment zal de laatste aanroep returnen, waarna de aanroep daarvoor returnt, etc. en de stack ook weer wordt afgebroken.</p>
</aside>
<p><img data-src="../Images/stack-overflow.png" style="width:70.0%" /></p>
</section>
<section id="de-heap" class="slide level2">
<h2>De Heap</h2>
<aside class="notes">
<p>Waar BSS en Data voor statische data gebruikt wordt, is de heap voor dynamische data: data waarvan tijdens het programmeren en compilen nog niet bekend is hoeveel ruimte ervoor nodig is. De heap wordt tijdens het uitvoeren van de code expliciet toebedeeld (gealloceerd).</p>
</aside>
<ul>
<li>Dynamische alloceerbaar</li>
<li>Expliciet ruimte reserveren</li>
<li>Na gebruik vrijgeven</li>
</ul>
</section>
<section id="memory-allocation" class="slide level2">
<h2>Memory Allocation</h2>
<aside class="notes">
<p>Met behulp van <code>malloc</code> en <code>free</code> geeft de software aan hoeveel geheugenadressen in de adresruimte gekoppeld moet worden aan daadwerkelijk heap-geheugen, zodat de software deze kan gebruiken. Bij het gebruik van <code>malloc</code> moet worden aangegeven hoeveel ruimte nodig is, maar dit kan in de software berekend worden op basis van bijvoorbeeld input. Waar dit geheugen komt te staan wordt door het OS bepaald, maar het zal altijd een aaneengesloten stuk geheugen zijn. Geheugen moet altijd teruggegeven worden om te voorkomen dat er memory leaks onstaan, en het is niet toegestaan geheugen aan te spreken dat niet gealloceerd is (dit leidt tot de error “segmentation fault”). Het niet teruggeven van gereserveerd geheugen is een van de meest voorkomende fouten bij veel latere TI vakken. Onder water wordt gebruik gemaakt van system calls waaronder <code>mmap</code>, <code>brk</code> en <code>munmap</code>. De aanroep naar <code>malloc</code> gebruikt bijvoorbeeld intern ergens een aanroep in de trant van <code>syscall(SYS_brk, 128*128*3)</code> om het besturingssysteem te vragen de ruimte vrij te maken. <code>SYS_brk</code> is een constante met de waarde <code>12</code>, het nummer van de system call.</p>
</aside>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">// reserveer ruimte voor 128x128 pixels met 3 bytes per pixel</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="dt">int</span> *img_data = malloc(<span class="dv">128</span>*<span class="dv">128</span>*<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co">// img_data verwijst naar begin van de gereserveerde ruimte</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">free(img_data); <span class="co">// geef de ruimte terug aan het OS</span></a></code></pre></div>
<h3 id="onder-water">Onder water</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="dt">int</span> *img_data = syscall(SYS_brk, <span class="dv">128</span>*<span class="dv">128</span>*<span class="dv">3</span>);</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">syscall(SYS_munmap, img_data, <span class="dv">128</span>*<span class="dv">128</span>*<span class="dv">3</span>);</a></code></pre></div>
</section>
<section id="in-code" class="slide level2">
<h2>In code</h2>
<aside class="notes">
<p>Dit hoeven jullie nog niet te kennen, dit is enkel te illustratie om de geheugengebieden iets concreter te maken. Maak je geen zorgen als je code-elementen nog niet herkent.</p>
</aside>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="dt">int</span> x;                  <span class="co">// Globale variabele zonder initiële waarde staat in BSS</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dt">int</span> y = <span class="dv">0</span>;              <span class="co">// Globale variabele met initiële waarde staat in DATA</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="dt">int</span> main(<span class="dt">void</span>)          <span class="co">// Code staat in TEXT</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">{ <span class="at">static</span> <span class="dt">int</span> i = <span class="dv">10</span>;    <span class="co">// Statische variabele met initiële waarde staat in DATA</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  <span class="at">static</span> <span class="dt">int</span> j;         <span class="co">// Statische variabele zonder initiële waarde staat in BSS</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  <span class="dt">int</span> k = <span class="dv">42</span>;           <span class="co">// Functie-variabele staat in de STACK</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  vector&lt;<span class="dt">int</span>&gt; v = {<span class="dv">0</span>,<span class="dv">1</span>} <span class="co">// Data van de vector staat in de HEAP</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  <span class="dt">int</span> *m = malloc(<span class="dv">12</span>);  <span class="co">// Ook malloc() reserveert op de HEAP</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  <span class="cf">return</span> <span class="dv">0</span>; }</a></code></pre></div>
</section>
<section id="wat-hebben-we-deze-les-geleerd" class="slide level2">
<h2>Wat hebben we deze les geleerd?</h2>
<ul>
<li>Wat is een OS?</li>
<li>Waarom is een OS nodig?</li>
<li>Wat is de basisarchitectuur van een OS?</li>
<li>Wat zijn voorbeelden van OSs?</li>
<li>Wat is User mode vs Kernel mode?</li>
<li>Wat zijn system calls?</li>
<li>Hoe ziet een enkel proces eruit?</li>
</ul>
</section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display the page number of the current slide
        slideNumber: 'c/t',
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom
        // Transition style for full page slide backgrounds
        backgroundTransition: 'slide', // none/fade/slide/convex/concave/zoom
        math: {
          mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/math/math.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
