<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Embedded &amp; Operating Systems 2">
  <title>Processen, Scheduling en Communicatie</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Processen, Scheduling en Communicatie</h1>
  <p class="author">Embedded &amp; Operating Systems 2</p>
</section>

<section id="introductie" class="slide level2">
<h2>Introductie</h2>
<aside class="notes">
<p>Vorige week zijn we onze tour door de interne werking van het OS gestopt bij het geheugenmodel van een enkele taak. Doorgaans draaien op een computer echter vele taken tegelijkertijd: ieder programma heeft op z’n minst een eigen taak (en soms veel meer, bijvoorbeeld een taak per tabblad in de Browser). Deze les gaan we kijken hoe de computer hiermee om kan gaan.</p>
</aside>
<figure>
<img data-src="images/Process.png" alt="Geheugenmodel Proces" style="width:30.0%" /><figcaption>Geheugenmodel Proces</figcaption>
</figure>
</section>
<section id="processen-op-één-core" class="slide level2">
<h2>Processen op één core</h2>
<aside class="notes">
<p>Het geheugenmodel van vorige week komt mooi overeen met hoe een proces er van binnen uitziet, alleen heb je er dan dus meerdere. De kernel code is in beide processen aanwezig, maar staat maar op één plek in het geheugen. Hoe dat werkt komen we op terug.</p>
</aside>
<figure>
<img data-src="images/Processes.png" alt="Meerdere Processen" style="width:60.0%" /><figcaption>Meerdere Processen</figcaption>
</figure>
</section>
<section id="meerdere-cores" class="slide level2">
<h2>Meerdere cores</h2>
<aside class="notes">
<p>Bij meerdere cores draait hetzelfde proces nooit op twee cores tegelijkertijd. Kernel code kan wel op meerdere cores actief zijn, waarom is dat?</p>
</aside>
<figure>
<img data-src="images/2cores.png" alt="Drie Processen, Twee Cores" style="width:80.0%" /><figcaption>Drie Processen, Twee Cores</figcaption>
</figure>
</section>
<section id="process-state" class="slide level2">
<h2>Process State</h2>
<aside class="notes">
<p>Een proces kan zich in meerdere toestanden bevinden. Een proces dat op dit moment CPU-tijd heeft, noemen we running. Als een proces niet actief is, omdat de CPU iets anders heeft te doen, dan noemen we dit ready-to-run of soms waiting. Die laatste naam heeft echter niet de voorkeur, omdat deze ook soms voor de derde state wordt gebruikt: blocked. Als een proces deze state heeft dan kan het proces niet verder omdat het op nieuwe data moet wachten, zoals bijvoorbeeld een toetsaanslag van de gebruiker of gegevens via een trage netwerkverbinding. Bij het bereiken van een van deze gevallen (ready-to-run en blocked) vindt een context-switch plaats en zal de processor met een ander proces verder gaan. Afhankelijk van de reden van deze switch zal de CPU het process opnieuw activeren zodra het aan de beurt is, of zodra het de benodigde gegevens heeft om verder te gaan.</p>
</aside>
<figure>
<img data-src="images/states.png" alt="Process State Diagram" style="width:80.0%" /><figcaption>Process State Diagram</figcaption>
</figure>
</section>
<section id="process-files" class="slide level2">
<h2>Process Files</h2>
<aside class="notes">
<p>Voor ieder proces is in het Linux filesysteem een virtueel bestand aanwezig. Dit is deel van de Unix filosofie: alles is een bestand. We gaan hier later meer van zien zodra we het Linux filesysteem gaan bekijken, maar dit is vast een voorbeeld waar we dit principe in actie zien.</p>
</aside>
<ul>
<li>Process IDs</li>
<li><code>/proc/PID</code> process directory
<ul>
<li><code>/proc/PID/exe</code></li>
<li><code>/proc/PID/cmdline</code></li>
<li><code>/proc/PID/environ</code></li>
<li><code>/proc/PID/stack</code></li>
<li>…</li>
</ul></li>
</ul>
</section>
<section id="threads" class="slide level2">
<h2>Threads</h2>
<aside class="notes">
<p>Een process kan meerdere threads bevatten en zo meerdere taken “tegelijkertijd” uitvoeren. Het afwisselen van threads gaat een stuk sneller dan het afwisselen van processen, en alle threads binnen een proces delen dezelfde data. Threads worden bijvoorbeeld gebruikt om de GUI en functionaliteit van een programma te scheiden: het programma kan verder terwijl de GUI geblokeerd is omdat deze wacht op gebruikersinvoer, en de GUI blijft responsive als de andere threads lang bezig zijn.</p>
</aside>
<div class="columns">
<div class="column" style="width:50%;">
<figure>
<img data-src="images/Threads.png" alt="Multithreaded Process" style="width:50.0%" /><figcaption>Multithreaded Process</figcaption>
</figure>
</div><div class="column" style="width:50%;">
<ul>
<li>Subprocessen</li>
<li>Eigen stack, registers</li>
<li>Gedeelde resources</li>
<li>Gedeelde code, eigen PC</li>
</ul>
</div>
</div>
</section>
<section id="context-switch" class="slide level2">
<h2>Context Switch</h2>
<aside class="notes">
<p>Bij het draaien van meerdere processen (of het aanroepen van een SysCall) moet de CPU constant vrijgemaakt worden voor een nieuwe taak. De oude informatie kan echter niet worden weggegooid, want deze is later weer nodig als de bijbehorende taak weer aan de beurt is. Dit noemen we een context switch: het OS zet alle state van het lopende proces opzij en laadt de nieuwe informatie. De informatie wordt opgeslagen in een Process Control Block (PCB) of Switchframe, en bevat de inhoud van de registers (met name de Program Counter) informatie over het proces, en informatie over welk geheugen bij het proces hoort. Dit laatste betekent dat het geheugen zelf niet verplaatst hoeft te worden, maar dat de CPU enkel de verwijzingen aan hoeft te passen.</p>
</aside>
<p><img data-src="images/Context%20Switch.png" style="width:80.0%" /></p>
</section>
<section id="scheduling" class="slide level2">
<h2>Scheduling</h2>
<aside class="notes">
<p>Of we nu met één of meerdere cores te maken hebben, het zal niet snel genoeg zijn om alle processen tegelijk te draaien. Het OS zal dus moeten bepalen hoeveel tijd iedereen heeft en wie wanneer aan de beurt is. Hiervoor zijn twee stijlen te onderscheiden: cooperative multitasking, waarbij de context switch door het proces wordt geïnitieerd en dus zelf bepaalt hoe lang het de CPU vast houdt, en pre-emptive multitasking, waarbij het OS na een bepaalde tijd een proces onderbreekt om te kijken wie er nu aan de beurt is. Wat zijn de voordelen van de twee stijlen, en wat zijn de nadelen? Wanneer zou je cooperative multitasking gebruiken? En wanneer niet?</p>
</aside>
<p><img data-src="images/2cores.png" style="width:80.0%" /></p>
<h4 id="strategiën">Strategiën</h4>
<ul>
<li>Cooperative Multitasking</li>
<li>Pre-emptive Multitasking</li>
</ul>
</section>
<section id="pre-emptive-multitasking" class="slide level2">
<h2>Pre-emptive Multitasking</h2>
<aside class="notes">
<p>We zoomen even in op pre-emptive multitasking. Hierbij ziet de context-switch er als volgt uit. De CPU interrupt wordt gedaan met behulp van een timer, zodat het lopende proces na een bepaalde tijd onderbroken wordt. De interrupt voert een simpele context-switch uit, van het proces naar de interrupt handler. Deze zal de rest van de process-state bewaren, eventuele achterstallige OS taken uitvoeren en de scheduler aanroepen. De scheduler heeft een lijst van alle processen. De scheduler weet welke processen belangrijker zijn en hoe lang geleden ieder proces aan de beurt is geweest. Op basis van deze factoren wordt een nieuw proces geselecteerd, waarna de state voor dat proces wordt klaargezet. Als dit gebeurt is kan het proces exact verder waar het gebleven was.</p>
</aside>
<ol type="1">
<li>CPU interrupt</li>
<li>Interrupt bewaart PC</li>
<li>Interrupt roept handler aan</li>
<li>Handler bewaart process state</li>
<li>Handler doet z’n werk</li>
<li>Handler roept de scheduler aan</li>
<li>Scheduler kiest een proces</li>
<li>Scheduler herstelt process state</li>
<li>Scheduler start proces</li>
</ol>
</section>
<section id="realtime" class="slide level2">
<h2>Realtime</h2>
<aside class="notes">
<p>Het schedulen is het meest complex wanneer we met realtime applicaties te maken hebben. Dit zijn processen waarbij een deadline geldt die gehaald dient te worden. We vergelijken vier processen: een lange berekening met weerdata (A), de sensor controller die de weerdata leest (B), Spotify (C) en de computer die een maanlander bestuurt (D). Ongeacht het verschil in de belangrijkheid van de taken, vallen de vier processen in vier verschillende categoriën met het oog op realtime. Proces A is (doorgaans) een voorbeeld van <em>not realtime</em>. Er is geen deadline, en hoewel het vervelend is als dit te lang duurt, maakt een vertraging het resultaat niet meteeen onbruikbaar (al ligt dit er natuurlijk wel aan waar de berekening toe dient). Proces B is een <em>soft realtime</em> proces; de deadlines mogen zo af en toe gemist worden, en hoe vaker de deadline niet gehaald wordt, des te groter is het waardeverlies. In dit geval zal de voorspelling op minder data gebaseerd zijn, en de waarde neemt af wanneer meer metingen worden gemist. Bij C spreken we van <em>firm realtime</em>: ook hier is het missen van een deadline nog acceptabel, zo lang het niet te vaak gebeurt. Waar bij soft realtime de waarde afneemt, is er bij firm realtime een punt waarop de resultaten waardeloos worden. Als Spotify te veel frames mist is het resultaat niet meer als muziek te herkennen. Voorbeeld D, tot slot, is een <em>hard realtime</em> systeem. Het missen van een enkele deadline kan leiden tot een crash, waarmee het hele resultaat in een klap (letterlijk) waardeloos is geworden.</p>
</aside>
<ul>
<li>Hard realtime</li>
<li>Firm realtime</li>
<li>Soft realtime</li>
<li>Not realtime</li>
</ul>
</section>
<section id="scheduling-strategiën" class="slide level2">
<h2>Scheduling Strategiën</h2>
<aside class="notes">
<p>Afhankelijk van het type realtime en de lengte van de deadlines kan de CPU verschillende strategiën gebruiken voor het schedulen van taken. De belangrijkste vormen zijn Rate Monotonic Scheduling en Earliest Deadline First. Bij RMS wordt de prioriteit van een taak gebaseerd op hoe lang deze taak nodig heeft. Kortere taken hebben een hogere prioriteit en komen vaker aan de beurt. Bij EDF wordt gekeken naar de deadline van een proces: wanneer moet het proces resultaten opleveren. Processen die minder speling hebben komen eerder aan de beurt.</p>
</aside>
<ul>
<li>Rate Monotonic Scheduling</li>
<li>Earliest Deadline First</li>
</ul>
</section>
<section id="inter-process-communication" class="slide level2">
<h2>Inter Process Communication</h2>
<aside class="notes">
<p>Vaak moeten meerdere processen samenwerken om een doel te bereiken. Als je een mail binnenkrijgt dan zal dit bijvoorbeeld door je mailprogramma worden binnengehaald. Ondertussen zorgt een ander proces ervoor dat je een notificatie in je scherm krijgt, en is er mogelijk nog een aparte notificatielijst, of een widget op het bureaublad, of… Met andere woorden: dezelfde informatie is vaak in meerdere processen nodig. Om de info te kunnen delen kennen we twee belangrijke varianten. Shared Memory en Message Passing.</p>
</aside>
<ul>
<li>Shared Memory</li>
<li>Message Passing</li>
</ul>
</section>
<section id="shared-memory" class="slide level2">
<h2>Shared Memory</h2>
<aside class="notes">
<p>In eerste instantie werd voor dit soort problemen vooral gebruik gemaakt van shared memory: stukken geheugen die door meerdere processen te lezen en schrijven zijn. Dit kan echter makkelijk misgaan; stel bijvoorbeeld het volgende scenario voor: Twee processen willen beide een bestand afdrukken. Proces A is aan de beurt, en zoekt de eerste vrije plaats in de wachtrij. Op dit moment gebeurt er een context switch, en is Proces B is aan de beurt. Ook deze zoekt de eerste vrije plaats, en zet op dat geheugenadres (hetzelfde adres als A had gevonden) een verwijzing naar een te printen bestand. Na de volgende context switch is A weer aan de beurt, die op hetzelfde adres een ander bestand zet. Het originele bestand is overschreven, zonder dat A of B dit gemerkt heeft.</p>
</aside>
<p><img data-src="images/overwrite.png" style="width:80.0%" /></p>
</section>
<section id="shared-memory-1" class="slide level2">
<h2>Shared Memory</h2>
<aside class="notes">
<p>Gelukkkig zijn hier oplossingen voor, maar die voegen een hoop complexiteit toe en zijn vaak lastig toe te passen, zeker in grotere systemen. Voorbeelden hiervan zijn mutexes (Mutual Exclusion) en Semaphores (vlaggen die aangeven dat een stuk geheugen in gebruik is), maar hier gaan we deze cursus verder niet op in.</p>
</aside>
<p><img data-src="images/skeleton.jpg" style="width:30.0%" /></p>
</section>
<section id="alternatief-message-passing" class="slide level2">
<h2>Alternatief: Message Passing</h2>
<aside class="notes">
<p>Een alternatief is message passing: beide processen communiceren via een naar een printer manager proces, dat alleenrechten heeft op het betreffende stuk geheugen.</p>
</aside>
<p><img data-src="images/messages.png" style="width:80.0%" /></p>
</section>
<section id="inter-process-communication-1" class="slide level2">
<h2>Inter Process Communication</h2>
<aside class="notes">
<p>Beide variaties zijn in de meeste moderne operating systems aanwezig. Shared memory wordt soms via bestanden toegepast, voor message passing zijn in Unix sockets aanwezig (die zowel over het netwerk als binnen het OS bruikbaar zijn). Hier worden de system calls <code>send</code> en <code>receive</code> getoond, die op Linux beschikbaar zijn om over sockets te communiceren.</p>
</aside>
<ul>
<li>Shared Files</li>
<li>Sockets / Unix Domain Socket</li>
<li>Message Queue</li>
<li>Pipes</li>
</ul>
</section>
<section id="processen-in-linux" class="slide level2">
<h2>Processen in Linux</h2>
<aside class="notes">
<p>In Linux zijn processen in een tree georganiseerd. Ieder proces heeft een parent, met uitzondering van het <em>init</em> proces dat de root van de tree vormt. Dit proces wordt als eerste gestart en heeft PID 1. Alle processen stammen van init af, en verweesde processen worden door init geadopteerd.</p>
</aside>
<p><img data-src="images/processtree.png" style="width:80.0%" /></p>
</section>
<section id="sys_fork" class="slide level2">
<h2><code>SYS_fork</code></h2>
<aside class="notes">
<p>De enige manier om een nieuw proces te starten in Linux is een beetje merkwaardig: met <code>fork()</code> kan een proces zichzelf geheel dupliceren, waarna je twee vrijwel identieke processen hebt die verder gaan na de <code>fork</code> call. Het enige verschil is de return-waarde van de <code>fork</code>: voor het parent proces zal dit de PID van de kopie zijn, maar voor het kind is deze 0. Dit klinkt wat omslachtig, maar het valt mee: beide processen delen hetzelfde geheugen totdat er ergens iets veranderd wordt, pas dan wordt er een kopie gemaakt van het geheugendeel in kwestie. Het geheugen is als copy-on-write (CoW) gemarkeerd, en op het moment dat een van beide processen probeert te schrijven volgt een interrupt, waarna de kernel ervoor zorgt dat het benodigde geheugen gekopieerd wordt.</p>
</aside>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="cf">if</span> (syscall(SYS_fork) == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">{ </a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="co">// This is the child </span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="co">// Do child stuff</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="cf">else</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">{ </a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="co">// This is the parent </span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="co">// Do parent stuff</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">}</a></code></pre></div>
</section>
<section id="sys_exec-en-sys_wait" class="slide level2">
<h2><code>SYS_exec</code> en <code>SYS_wait</code></h2>
<aside class="notes">
<p>Hoewel het mogelijk is beide ge<code>fork</code>te processen met dezelfde code door te laten draaien, is dit doorgaans niet hoe <code>fork</code> gebruikt wordt. In plaats daarvan zal een van beide processen, doorgaans het kind, een <code>execve</code> system call doen om een andere executable uit te voeren. Het gehele geadreseerde geheugen wordt weggegooid, en de code uit de executable wordt ingeladen als text segment. De data en bss worden geïnitialiseerd, en het proces heeft een lege heap en stack. Het programma begint met de <code>main()</code> van de executable. Het parent proces kan de originele code hervatten, maar zal in veel gevallen wachten tot het kind doodgaat. Hiervoor wordt de <code>wait</code> system call gebruikt, met het PID van het kind. Hoewel dit wat tragisch klinkt, is het in Unix een groter probleem als de parent komt te overleiden terwijl de child nog leeft: in dat geval hebben we een orphan (weesproces), dat door het init process wordt geadopteerd. Als de parent besluit niet op het kind te wachten, en dit komt te overleiden, dan zal het kind niet direct verwijderd worden. Het proces is welliswaar beëindigd, maar komt nog wel in de procestabel voor tot de parent het overleiden heeft geregistreerd door de exit-code te lezen. Tot die tijd wordt dit kind een zombie-proces genoemd.</p>
</aside>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dt">int</span> pid = fork();</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="cf">if</span> (pid == <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">{ </a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="co">// Execute another process</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  <span class="dt">char</span> *args[] = {<span class="st">&quot;/bin/ls&quot;</span>,<span class="st">&quot;-r&quot;</span>, <span class="st">&quot;-t&quot;</span>, <span class="st">&quot;-l&quot;</span>, (<span class="dt">char</span> *) <span class="dv">0</span> };</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  execv(<span class="st">&quot;/bin/ls&quot;</span>, args);</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">}</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="cf">else</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">{ </a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="co">// Wait for child to die</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  <span class="dt">int</span> exit_status;</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  wait(&amp;exit_status);</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">}</a></code></pre></div>
</section>
<section id="sys_exit" class="slide level2">
<h2><code>SYS_exit</code></h2>
<aside class="notes">
<p>Een proces dat klaar is zal zichzelf beëindigen met behulp van de <code>SYS_exit</code> call. Deze krijgt een argument mee van het type <code>int</code>, die vertelt waarom het proces gestopt is. Dit wordt de exit-code genoemd. Een exit-code van <code>0</code> betekent dat alles goed is gegaan. Een ander getal duidt op een error, waarbij het specifieke getal gebruikt kan worden om de foutmelding aan te geven. Hiervoor is verder geen conventie, de betekenis van de overige exit-codes verschilt van programma tot programma.</p>
</aside>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb3-1" data-line-number="1">syscall(SYS_exit, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">// of</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">_exit(<span class="dv">0</span>);</a></code></pre></div>
</section>
<section id="states-revisited" class="slide level2">
<h2>States (revisited)</h2>
<aside class="notes">
<p>Inmiddels hebben we het hele plaatje, inclusief de system calls die aan het begin en einde van het leven van een proces staan.</p>
</aside>
<figure>
<img data-src="images/states2.png" alt="Process State Diagram" style="width:60.0%" /><figcaption>Process State Diagram</figcaption>
</figure>
</section>
<section id="wat-hebben-we-deze-les-geleerd" class="slide level2">
<h2>Wat hebben we deze les geleerd?</h2>
<ul>
<li>Wat zijn processen en threads?</li>
<li>Wat zijn de toestanden waarin een proces zijn?</li>
<li>Wat is een context switch?</li>
<li>Hoe werkt scheduling?</li>
<li>Wat is realtime?</li>
<li>Hoe werkt inter-process communication?</li>
<li>Welke system-calls maken en beëindigen processen?</li>
</ul>
</section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
