<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Embedded &amp; Operating Systems 5">
  <title>Bash Scripting</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section id="title-slide">
  <h1 class="title">Bash Scripting</h1>
  <p class="author">Embedded &amp; Operating Systems 5</p>
</section>

<section id="introductie" class="slide level2">
<h2>Introductie</h2>
<aside class="notes">
<p>Uitvoeren shell script is vergelijkbaar met interactieve shell: STDIN is file i.p.v. user interaction.</p>
</aside>
<!--
Vorige week hebben we gezien hoe we ons kunnen redden op de Bash command line. Vandaag zullen we nog een aantal meer geavanceerde opties zien, maar zullen we vooral de focus verleggen. Waar we de shell vorige les interactief gebruikt, gaan we nu aan de gang met shellscripts: voorgeprogrammeerde programma's om te doorlopen. In plaats van dat `STDIN` direct door ons als gebruiker gevuld wordt, wordt hiervoor een bestand ingelezen. Dit verschil maakt voor de shell in principe niets uit, in beide gevallen is er een lijst met commando's. In het geval van een interactieve moet er zo af en toe gewacht worden op de gebruiker, terwijl bij een script op de harde schijf of het geheugen gewacht moet worden.
-->
</section>
<section id="shebang-en-chmod" class="slide level2">
<h2>Shebang en <code>chmod</code></h2>
<aside class="notes">
<ul>
<li><code>bash script</code> werkt altijd</li>
<li>Bestand moet uitvoerbaar zijn voor <code>./script</code></li>
<li><code>chmod +x</code> zet executable bit voor bestand</li>
<li>Maar hoe ziet linux verschil text file en bash script (of python)?</li>
<li>Eerste regel bevat <code>#!</code> plus pad interpreter (bash, python, …)</li>
<li><code>file</code> laat zien hoe Linux bestand herkent</li>
<li><code>env</code> zoekt pad zelf op, moderner en werkt met nonstandaard locaties</li>
</ul>
</aside>
<!-- 
Als we een serie Bash commands in een bestand onder elkaar zetten, hebben we in principe al een simpel script dat we met `bash scriptfile` kunnen uitvoeren. Een scriptfile mag elke extensie hebben, vaak wordt de `.sh` uitgang gebruikt. Ook komt het vaak voor dat er geen extensie gebruikt wordt, om als bona fide programma over te komen. Dat laatste heeft vooral zin als we het programma direct met de naam (e.g. `scriptfile`) aan kunnen roepen. Gelukkig is dat makkelijk te doen, al moeten we hier wel twee stappen voor uitvoeren: we moeten Linux vertellen wat voor code het bestand bevat, en dat het uitgevoerd mag worden. Dat eerste doen we met het commando `chmod +x scriptfile`. We zullen later verder naar `chmod` kijken, zodra het rechtensysteem aan bod komt, maar voor nu kunnen we dit lezen als "voeg de eXecutable bit to voer het bestand `scriptfile`".
Daarnaast moet Linux kunnen zien dat het bestand Bash code bevat, en niet Python of C++ of nog iets anders. Het moet weten welke _interpreter_ gebruikt moet worden. In Windows wordt doorgaans de extensie gebruikt om een bestandtype te herkennen, maar omdat in Linux de koppeling tussen bestand en bestandsnaam wat losser is (zoals we in Les 7 zullen zien) kijkt Linux liever naar de inhoud van het bestand. Op basis van de eerste paar bytes zijn de meeste bestandtypes te herkennen. Je kunt dit uitproberen met de tool `file`, die vertelt wat voor bestandstype Linux denkt dat bij het bestand hoort. Scriptfiles zijn bestanden met tekstdata die te herkennen zijn aan een verwijzing naar de juiste interpreter op de eerste regel: deze moet met `#!` beginnen, gevolgd door het pad naar de gewenste interpreter. Als je script met `#!/bin/bash` begint, zal `file` (en daarmee Linux) het correct als een Bash script identificeren.
Als we beide stappen hebben doorlopen, uitvoerbaar maken en de shebang toevoegen, kunnen we het bestand uitvoeren met `./scriptfile` -- toch alweer iets korter dan `bash scriptfile`.
**Noot:** In plaats van `#!/bin/bash` wordt tegenwoordig liever `#!/usr/bin/env bash` gebruikt (al kom je de oudere vorm nog vaker tegen). Bij de nieuwe variant wordt het programma `env` gebruikt om de juiste interpreter ergens in het `PATH` (meer daarover op de volgende slide) te vinden. Programma's staan niet bij alle Linux distributies op dezelfde plek, en soms is een programma niet op systeemniveau maar binnen de home directory van een gebruiker geïnstalleerd. Door `env` te gebruiken kan bash gevonden worden zo lang je `bash` op een command line kan aanroepen.
-->
<ul>
<li><code>bash scriptfile</code></li>
<li><code>chmod +x scriptfile</code></li>
<li>Interpreters</li>
<li><code>#!/bin/bash</code> of <code>#!/usr/bin/env bash</code></li>
<li><code>file</code></li>
<li><code>./scriptfile</code></li>
</ul>
</section>
<section id="path-en-which" class="slide level2">
<h2><code>PATH</code> en <code>which</code></h2>
<!--
Hoewel `./scriptname` al wat beter is dan `bash scriptname`, is het nog steeds opvallend anders dan de meeste andere commands. Dit heeft te maken met de `$PATH` variabele. Deze variabele bevat een lijst met mappen, en alleen programma's of scripts in één van deze mappen kunnen zonder pad worden uitgevoerd. Zo niet, dan moet iedere aanroep met `./`, `../`, `/`, of `~/` beginnen.
De waarde van `$PATH` is met `echo $PATH` te lezen, of met `env` (die alle environment variabelen print). Als we ons script in een directory zetten die in het `$PATH` voorkomt, zal het van overal aan te roepen zijn. 
Ook kunnen we en map aan ons pad toevoegen. Om bijvoorbeeld de map `~/bin` toe te voegen, gebruik je `PATH=~/bin:$PATH`. De `:` is een scheidingsteken dat we gebruiken om de toegevoegde map met het oude `$PATH` te combineren. We zetten de map vooraan, wat betekent dat dit de eerste map is waar de shell gaat zoeken. We kunnen bijvoorbeeld een eigen versie van `mv` maken, die ergens een logbestand bijhoudt; als we deze nu in `~/bin` zetten dan verwijst het commando `mv` naar `~/bin/mv` en niet meer naar `/bin/mv`.
Tot slot kunnen we de variabele alleen voor een subprocess aanpassen door `env PATH=~/bin` voor een commando te zetten, bijvoorbeeld `env PATH=~/bin bash` om een nieuwe Bash instantie te openen met enkel `~/bin` in het `$PATH`.
-->
<aside class="notes">
<ul>
<li>Nog steeds niet script als commando</li>
<li>Linux zoekt niet in huidige map voor commands</li>
<li>Veiliger: was als bestand ‘cp’ met virus gedownload wordt?</li>
<li><code>$PATH</code> bevat mappen waar Linux zoekt (in volgorde)</li>
<li>Script in juiste map, of map aan <code>$PATH</code> toevoegen</li>
<li><code>echo $PATH</code></li>
<li>Aanvullen met <code>:$PATH</code>, concat toevoeging met oude PATH</li>
<li><code>env PATH=~/bin command</code> voor eenmalig PATH bij command</li>
</ul>
</aside>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="va">PATH=</span>~/bin:<span class="va">$PATH</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="bu">export</span> <span class="va">PATH=</span>~/bin:<span class="va">$PATH</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="fu">env</span> PATH=~/bin command</a></code></pre></div>
</section>
<section id="bashrc" class="slide level2">
<h2><code>.bashrc</code></h2>
<!--
De wijziging aan `$PATH` die we gedaan hebben geldt alleen voor het huidige proces. Een andere shell zal de aanpassing niet overnemen, zelfs niet als we die vanaf de shell met het nieuwe `$PATH` aanroepen. Door `export PATH=~/bin:$PATH` te gebruiken zal de variabele wel doorgegeven worden aan subprocessen. Een onfhankelijk geopende shell weet nog steeds niet van ons nieuwe `$PATH` af, hiervoor moeten we de `export PATH=~/bin:$PATH` in elke nieuwe shell draaien.
Hiervoor is het bestand `~/.bashrc`. De code in dit bestand wordt in iedere nieuwe Bash shell uitgevoerd. Door onze aanpassingen daar neer te zetten, hebben die voor elke (nieuwe) shell effect.
Naast `export`s van variabelen wordt `.bashrc` ook veel gebruikt voor het `alias` commando. Hiermee kun je eenvoudig nieuwe commando's aanmaken, zo lang deze gebaseerd zijn op bestaande commando's. We zullen straks zien hoe we ook complexere functies kunnen toevoegen, maar in veel simpele gevallen is een `alias` voldoende. Je kunt een alias voor een bestaand commando maken, zoals `sl` voor `ls` als je dit vaak verkeerd typt. Daarnaast kun je een bestaand commando hiermee standaard opties geven.
Naast `.bashrc` hebben we `.bash_profile`. Beide vervullen eenzelfde taak, maar `.bash_profile` wordt voor login shells gebruikt (in de praktijk alleen als je in een kernel level virtual terminal), `.bashrc` voor non-login shells. Dit kun je gebruiken om bijvoorbeeld extra informatie te printen bij een login-shell die je niet in iedere nieuwe terminal nodig hebt.
Meestal wordt `.bash_profile` ingesteld om ook `.bashrc` te laden, zodat deze alle algemene informatie (voor alle shells) bevat en `.bash_profile` gebruikt kan worden voor specifieke code voor login shells. Hiervoor gebruiken we het code-voorbeeld op de slide. Aan het einde van deze les zou je de code ook moeten kunnen begrijpen.
-->
<aside class="notes">
<ul>
<li>Aanpassingen zoals PATH alleen in huidige shell</li>
<li>Beter in bashrc of bash_profile zetten</li>
<li>bashrc voor niet login shells, bash_profile voor login shells (t.b.v. extra info bij login)</li>
<li>Mogelijk bashrc in bash_profile te laden</li>
<li>Ook vaak in bashrc: <code>alias</code> om een alias aan te maken</li>
<li>e.g. typefouten, standaard opties, veelgebruikte lange commando’s</li>
</ul>
</aside>
<ul>
<li><code>alias sl='ls'</code></li>
<li><code>alias ls='ls -la'</code></li>
<li><code>alias avadaKedavra='killall -9</code></li>
<li><code>.bashrc</code> vs <code>.bash_profile</code></li>
</ul>
<p> </p>
<h4 id="bash_profile"><code>.bash_profile</code></h4>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">if</span><span class="bu"> [</span> <span class="ot">-f</span> ~/.bashrc<span class="bu"> ]</span>; <span class="kw">then</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">   <span class="bu">source</span> ~/.bashrc</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">fi</span></a></code></pre></div>
</section>
<section id="bash-bestanden-laden-zonder-subshell" class="slide level2">
<h2>Bash bestanden laden zonder subshell</h2>
<!--
De `.bash_profile` en `.bashrc` worden standaard bij het opstarten door Bash gelezen. In dit geval wordt alle code in de (net aangemaakte maar) bestaande shell uitgevoerd. Dit is anders dan wanneer je een Bash script aanroept, hiervoor wordt namelijk een nieuw Bash proces aangemaakt. Dit betekent ook dat als je een script hebt waar variabelen in worden ingesteld, deze alleen in de subshell worden uitgevoerd en weer verdwenen zijn zodra het script beëindigd is. Als het zetten van variabelen de taak van het script is, is dit niet wat je wilt.
Gelukkig kun je ook bestaande code uitvoeren in de huidige shell. Dit gebeurt met `. filename` of `source filename` (`source` is een alias voor `.`).
Scripts die bedoeld zijn om te `source`n en niet in een subshell uitgevoerd mogen worden kunnen de shebang `#!/bin/false` krijgen: Bash probeert de code met `false` uit te voeren, een programma dat zichzelf altijd direct met een non-zero return value beëindigd (en dus een fout simuleert). Het script wordt dus niet uitgevoerd, en de gebruiker krijgt een melding dat er iets niet naar behoren is gegaan.
-->
<aside class="notes">
<ul>
<li><code>./.bashrc</code> maakt nieuwe shell, voert uit en keert terug; aanpassingen blijven achter in subshell</li>
<li>in plaats daarvan source of “punt” om in huidige shell te laden</li>
<li><code>#!/bin/false</code> voorkomt dat script per ongeluk verkeerd wordt uitgevoerd: stopt meteen met foutmelding</li>
</ul>
</aside>
<ul>
<li><code>. .bashrc</code></li>
<li><code>source .bashrc</code></li>
<li><code>#!/bin/false</code></li>
</ul>
</section>
<section id="if" class="slide level2">
<h2>If</h2>
<!--
Nu we weten hoe we een shell script schrijven en kunnen uitvoeren, is het tijd om naar wat code te gaan kijken. We kunnen natuurlijk wat commando's achter elkaar zetten en het gezegend vinden, maar als we echt wat willen programmeren dan moeten we keuzes kunnen maken. We hebben al gezien hoe we `&&` en `||` kunnen gebruiken om de exit status van een proces te gebruiken om te bepalen om wel of niet de volgende instructie uit te voeren (als A dan B) maar complexere keuzes zijn minder eenvoudig (als A dan B anders C). Hiervoor hebben we in Bash een `if-then-else` constructie. Deze heeft de vorm `if commandoA; then commandoB; else commandoC; fi`. De puntkomma is in Bash equivalent aan een nieuwe regel, je kunt dit dus ook op meerdere regels doen zonder de puntkomma's nodig te hebben. Het format op de slides kom je vaak tegen, maar is niet de enige manier. Het inspringen is niet noodzakelijk, maar wel leesbaar.
Het eerste commando, `commandoA` bepaalt welk pad gekozen wordt. Net als bij `&&` en `||` gebeurt dit op basis van de exit-code: `0` is `true`, elk ander getal is `false` (dit is dus precies anders dan in de meeste talen, waaronder Python). `then` en `else` geven aan waar de volgende code-blokken beginnen, en `fi` (`if` achterstevoren) beëindigd het `if`-statement.
-->
<aside class="notes">
<ul>
<li><code>&amp;&amp;</code> en <code>||</code> voor keuzes, maar kan makkelijker</li>
<li>if then else</li>
<li>gebaseerd op return value <code>if</code> gedeelte (kunnen meerdere commands zijn)</li>
</ul>
</aside>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co"># Download een bestand</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="kw">if</span> <span class="fu">wget</span> http://test.me/audio.mp3<span class="kw">;</span> <span class="kw">then</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="co"># Speel een audiobestand</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="ex">mpg123</span> audio.mp3</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">else</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  <span class="bu">echo</span> <span class="st">&quot;Failure&quot;</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">fi</span></a></code></pre></div>
</section>
<section id="test" class="slide level2">
<h2>Test</h2>
<!--
Vaak willen we testen of een bestand bestaat: bij een CSV bestand willen we bijvoorbeeld een nieuwe rij toevoegen, maar als het nog niet bestaat moeten we het maken met de header row. Hiervoor hebben we het `test` commando beschikbaar. Met `test -e` testen we of iets bestaat, met `test -f` of het ook nog een bestand is (en geen map) en met `test -d` of het een directory is. Daarnaast zijn er nog vele andere opties om bestanden te testen, hiervoor moet je de `man`-page raadplegen.
Het `test` commando kan ook gebruikt worden met strings (`test -n $STRING` test of een string niet leeg is, `test $A = $B` test of twee strings gelijk zijn, ...) en getallen (`test $A -eq $B` test of de getallen gelijk zijn, ...) — ook hiervoor moet je in de `man`-page zijn.
Tot slot kun je in één aanroep naar `test` meerdere exnotessies combineren. `test <TEST1> -a <TEST2>` is de _and_ en `test <TEST1> -o <TEST2>` is de _or_. Je kunt een uitroepteken gebruiken voor _not_, en haakjes om testen te combineren.
Een alternatief voor `test` is de blokhaakjes-notatie. Onderwater gebeurt hetzelfde, maar de code kan iets beter leesbaar zijn. `[` is een shorthand voor `test`, met de extra voorwaarde dat het laatste argument `]` is. Zowel bij `test` als bij `[..]` geldt dat je op moet letten met de spatiëring. Iedere operator is een commando of argument, dus moet door een spatie gescheiden zijn. `[-d '/tmp']` werkt niet, dit moet `[ -d '/tmp' ]` zijn. Hetzelfde geldt bijvoorbeeld voor het uitroepteken. De haakjes zijn een command op zich, geen onderdeel van de `if`-syntax. Bij twijfel: zorg dat overal een spatie tussen staat.
-->
<aside class="notes">
<ul>
<li>test of blokhaaksyntax te gebruiken om te testen of bestanden / directories bestaan, etc</li>
<li>return value 0 als audio.mp3 bestaat, dus <code>then</code>, zo niet: <code>else</code></li>
<li>blokhaak openen is synoniem voor test, maar heeft als laatste argument sluithaak nodig</li>
<li>spaties noodzakelijk!</li>
</ul>
</aside>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">if</span> <span class="bu">test</span> -e audio.mp3<span class="kw">;</span> <span class="kw">then</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="co"># Speel een audiobestand</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="ex">mpg123</span> audio.mp3</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">else</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="bu">echo</span> <span class="st">&quot;Failure&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="kw">fi</span></a></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">if</span><span class="bu"> [</span> <span class="ot">-e</span> audio.mp3<span class="bu"> ]</span>; <span class="kw">then</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="co"># Speel een audiobestand</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="ex">mpg123</span> audio.mp3</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">else</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="bu">echo</span> <span class="st">&quot;Failure&quot;</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">fi</span></a></code></pre></div>
</section>
<section id="case" class="slide level2">
<h2>Case</h2>
<!--
Meerdere keuzes zijn ook mogelijk: de `case`-constructie vergelijkt een variabele met meerdere opties. Neem bijvoorbeeld een `.bashrc`-bestand dat op meerdere systemen gebruikt wordt. Sommige code is algemeen, andere is misschien wat meer systeem-specifiek. We kunnen in dit geval de `case` constructie gebruiken om op de `$HOSTNAME` variabele te splitsen (deze bevat de hostname, die per systeem anders zou moeten zijn). De code op de slide bevat specifieke code voor de Raspberry Pi (genaamd _Pi_), de laptop (genaamd _Voyager_) en de pc (genaamd _Defiant_). De constructie begint met `case $VARIABELE in`, gevolgd door een aantal opties. Iedere optie begint met de te matchen string, gevolgd door een sluit-haakje: `Pi)`. De regels hierna worden alleen op de Pi uitgevoerd, tot aan de dubbele puntkomma `;;`. Je kunt `*)` gebruiken voor de `else`, en de hele constructie wordt met `esac` beëindigd (`case` achterstevoren).
-->
<aside class="notes">
<ul>
<li>Meerdere keuzes: <code>case</code></li>
<li>Voorbeeld: configuratiebestand op hostname</li>
<li>Vergelijkt HOSTNAME met Pi, Voyager etc</li>
<li>voert code uit na match, tot <code>;;</code></li>
<li><code>*)</code> als else</li>
</ul>
</aside>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">case</span> <span class="va">$HOSTNAME</span><span class="kw"> in</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  Pi<span class="kw">)</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="co"># Code voor de Raspberry Pi</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="kw">;;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  Voyager<span class="kw">)</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  <span class="co"># Code voor de laptop</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="kw">;;</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">  Defiant<span class="kw">)</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="co"># Code voor de PC</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  <span class="kw">;;</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  *<span class="kw">)</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  <span class="co"># Code voor als $HOSTNAME iets anders blijkt te zijn</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  <span class="kw">;;</span></a>
<a class="sourceLine" id="cb6-14" data-line-number="14"><span class="kw">esac</span></a></code></pre></div>
</section>
<section id="for" class="slide level2">
<h2>For</h2>
<!--
Naast keuzes willen we ook kunnen loopen: code een aantal keer uitvoeren, of herhalen tot een bepaald punt bereikt is. Hiervoor kennen we de `for` en `while` (en `until`) loops. De `for`-loop heeft weer twee varianten. Met de eerste variant wordt over een array gelopen, bijvoorbeeld om elk element te printen. Daarnaast ondersteunt Bash de C-style `for` loop, waarbij een variabele aangemaakt wordt die iedere keer opgehoogd wordt tot een bepaalde waarde wordt bereikt.
-->
<aside class="notes">
<ul>
<li>For loop voor herhaling: door array lopen of C style met iterator</li>
</ul>
</aside>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="bu">declare</span> -a <span class="va">ARRAY=(</span><span class="st">&#39;Christopher&#39;</span> <span class="st">&#39;David&#39;</span> <span class="st">&#39;Matt &#39;</span>Peter<span class="st">&#39; &#39;</span>Jodie<span class="st">&#39;)</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="st">for word in $ARRAY; do</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="st">  echo $word </span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="st">done</span></a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">for</span> <span class="kw">((</span>x=1; x&lt;=10; x++<span class="kw">))</span>; <span class="kw">do</span> </a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="bu">echo</span> <span class="va">$x</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">done</span></a></code></pre></div>
</section>
<section id="arrays" class="slide level2">
<h2>Arrays</h2>
<!--
In de vorige slides zagen we een array (ook wel lijst). Een lijst kan worden aangemaakt met `declare -a ARRAY`. Lege arrays worden aangemaakt met lege haakjes `()`. Een waarde binnen de array kan worden aangepast met `ARRAY[INDEX] = Foo`, waarbij we `INDEX` natuurlijk 0 is voor het eerste element. Om een waarde op te zoeken gebruiken we `${ARRAY[0]}`; de accolades worden gebruikt om aan te geven dat we de eerste waarde van `ARRAY` willen opzoeken, niet een variabele genaamd `ARRAY` met nog wat tekst erachteraan: `echo $ARRAY[0]` geeft (met de Array van hierboven) `Christopher[0]` terug. `$ARRAY` evalueert naar het eerste element in de lijst, en `[0]` wordt als deel van de argumenten van `echo` beschouwd. `$ARRAY` is dus hetzelfde als `${ARRAY[0]}`, en `ARRAY=John` vervangt niet de hele array door John, maar alleen het eerste element.
Je kunt in Bash ook arrays maken die niet met een integer, maar met een string geïndexeerd zijn (vergelijkbaar met de dict in Python). Dit heet een associative array, en wordt aangemaakt met `declare -A ARRAY`. Als je `$ARRAY` vraagt voor een associative array krijg je het element met index `"0"` als dit bestaat (anders een lege string). Tot slot kun je arrays uitbreiden met `+=`, zoals op de slide voorgedaan voor associative arrays. 
-->
<aside class="notes">
<ul>
<li><code>declare</code> voor maken arrays, kleine letter a is indexed, hoofdletter is dict achtig</li>
<li>array zonder zonder index/key -&gt; 0 of “0” (geen warning)</li>
<li><code>+=</code> voor toevoegen</li>
<li>Bij keys in Associative array altijd accolades gebruiken, anders niet als deel van var naam gezien</li>
<li>echo zonder haken → <code>Jim[0]</code> omdat <code>$ARRAY</code> zelf ook al <code>Jim</code> is.</li>
</ul>
</aside>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="bu">declare</span> -A <span class="va">ARRAY=([A]=</span>Jim <span class="va">[B]=</span>John <span class="va">[C]=</span>Rachel <span class="va">[D]=</span>Jean-Luc<span class="va">)</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="va">ARRAY=</span>Jim</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="bu">echo</span> <span class="va">${ARRAY[0]}</span> <span class="co"># Jim</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="va">ARRAY+=([E]=</span>Jean-Luc<span class="va">)</span></a></code></pre></div>
</section>
<section id="accolades-bij-variabelen" class="slide level2">
<h2>Accolades bij variabelen</h2>
<aside class="notes">
<p>Ook bij normale variabelen zijn accolades soms nodig, zoals wanneer er geen spatie achter de variabele mag komen.</p>
</aside>
<!--
De accolades die we nodig hadden om elementen uit de array te halen zijn niet specifiek voor arrays: deze mogen overal gebruikt worden wanneer er onduidelijkheid kan zijn of een teken bij de variabele-naam hoort of niet. Meestal kan een spatie gebruikt worden om het einde van de variabelenaam aan te geven, maar deze wordt dan ook geprint; als dit niet wenselijk is bieden de accolades uitkomst.
-->
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="va">FOO=</span><span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="bu">echo</span> <span class="va">$FOOd</span> <span class="co"># lege output</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="bu">echo</span> <span class="va">$FOO</span> d <span class="co"># foo d</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="bu">echo</span> <span class="va">${FOO}</span>d <span class="co"># food</span></a></code></pre></div>
</section>
<section id="while" class="slide level2">
<h2>While</h2>
<!--
Naast de `for`-loop ondersteunt Bash ook `while`- en `until` loops. Het verschil is dat bij `while` de loop herhaalt zo lang de stopconditie waar is, terwijl `until` doorgaat zo lang de stopconditie (nog) niet waar is. Net als met het `if`-statement is de keuze gebaseerd op de return value van het command (of de command list) voor het `do`-statement.
Daarnaast ondersteunen loops `break` (stop de loop) en `continue` (begin direct aan de volgende ronde door de loop), al wordt het aangeraden deze alleen te gebruiken wanneer strikt noodzakelijk omdat dit de leesbaarheid van de code niet helpt. Beide commands hebben een optioneel argument voor het werken met genestte loops: `break 2` stopt de binnenste twee loops, en gaat daarbuiten verder.
De return-value van de loop zelf is die van het laatste commando dat is uitgevoerd na `do`, of `0` als er niets is uitgevoerd.
-->
<aside class="notes">
<ul>
<li>While: zo lang de eerste command list waar is, herhaal beide</li>
<li>Until: totdat de eerste command list waar is, herhaal beide</li>
<li>In beide gevallen: exit code voor true/false</li>
</ul>
</aside>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">while</span> <span class="op">&lt;</span><span class="ex">commands</span><span class="op">&gt;</span><span class="kw">;</span> <span class="kw">do</span> </a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="op">&lt;</span><span class="ex">commands</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">done</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">until</span> <span class="op">&lt;</span><span class="ex">commands</span><span class="op">&gt;</span><span class="kw">;</span> <span class="kw">do</span> </a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  <span class="op">&lt;</span><span class="ex">commands</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">done</span></a></code></pre></div>
</section>
<section id="samengestelde-commandos" class="slide level2">
<h2>Samengestelde commando’s</h2>
<!--
Vorige week hebben we kennis gemaakt met de command-list. Om van een command-list weer één object te maken, kunnen we twee vormen gebruiken: gewone haakjes en accolades. Bij accolades moet het sluithaakje op een eigen regel staan (of voorafgegaan worden door een `;`); voor gewone haakjes is dit niet zo. Het verschil is waar de commands worden uitgevoerd: commands tussen accolades gebeuren binnen de huidige shell, terwijl bij haakjes een subshell geopend wordt: een apart proces. Dit houdt in dat wijzigingen aan de environment (bijvoorbeeld variabelen) de subshell niet overleven.
-->
<aside class="notes">
<ul>
<li>haakjes: command list in subshell</li>
<li>accolades: wel groeperen tot samengesteld commando, zelfde shell</li>
<li>van belang voor variabelen die in command list worden ingesteld</li>
</ul>
</aside>
<ul>
<li><code>( foo; bar &amp;&amp; baz )</code></li>
<li><code>{ foo; bar &amp;&amp; baz; }</code></li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="bu">cd</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="bu">echo</span> <span class="va">$PWD</span> <span class="co"># /home/username</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="kw">(</span> <span class="bu">cd</span> /<span class="kw">;</span> <span class="bu">echo</span> <span class="va">$PWD</span> <span class="kw">)</span> <span class="co"># /</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="bu">echo</span> <span class="va">$PWD</span> <span class="co"># /home/username</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="kw">{</span> <span class="bu">cd</span> /<span class="kw">;</span> <span class="bu">echo</span> <span class="va">$PWD</span> <span class="kw">}</span> <span class="co"># /</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="bu">echo</span> <span class="va">$PWD</span> <span class="co"># /</span></a></code></pre></div>
</section>
<section id="functions" class="slide level2">
<h2>Functions</h2>
<!--
Nu we de control structures kennen rest ons nog één belangrijke constructie om echte code te schrijven: de functie. De syntax hiervoor in Bash is `<naam> () <samengesteld commando> <io redirections>`. Samengesteld commands die we tot nu toe hebben gezien zijn een command-list tussen accolades of haakjes (zie de vorige slide) of een `for`, `select`, `if`, `while` of `until` constructie. Naast de "standaard" syntax kom je ook vaak vormen met het codewoord `function` tegen, al dan niet met de haakjes. Op de slide staan alle mogelijke combinaties. De haakjes zijn altijd leeg, argumenten worden bij het aanroepen van de functie in variabelen `$1`, `$2`, etc. Dit werkt hetzelfde als voor scriptbestanden. `$0` bevat in dat geval de naam van het script, of als die er niet is de naam van de shell. 
Na de body van de functie kunnen we nog IO redirections toepassen om de uitvoer bijvoorbeeld naar een bestand te schrijven. Deze redirections worden uitgevoerd als de functie wordt aangeroepen (bij het definiëren van de functie gebeurt niets). Je kunt hier ook functie-argumenten in gebruiken om een filename te maken.
-->
<aside class="notes">
<ul>
<li><code>&lt;naam&gt; () &lt;samengesteld commando&gt; &lt;eventuele IO redirects&gt;</code></li>
<li>function prefix mogelijk, ipv of naast haakjes</li>
<li>Argumenten via <code>$1</code>, niets binnen haakjes</li>
</ul>
</aside>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">filetype_count()</span> <span class="kw">{</span> <span class="fu">find</span> -name <span class="st">&quot;*.</span><span class="va">$1</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="fu">wc</span> -l<span class="kw">;</span> <span class="kw">}</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ex">filetype_count</span> <span class="st">&quot;jpg&quot;</span> <span class="co"># 31167</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="fu">filetype_count()</span> <span class="kw">{</span> <span class="fu">find</span> -name <span class="st">&quot;*.</span><span class="va">$1</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="fu">wc</span> -l<span class="kw">;</span> <span class="kw">}</span> <span class="op">&gt;</span> <span class="va">$2</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="ex">filetype_count</span> <span class="st">&quot;jpg&quot;</span> <span class="st">&quot;jpgcount&quot;</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="fu">cat</span> jpgcount <span class="co"># 31167</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="co"># Equivalente syntax</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="kw">function</span><span class="fu"> filetype_count()</span> <span class="kw">{</span> <span class="fu">find</span> -name <span class="st">&quot;*.</span><span class="va">$1</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="fu">wc</span> -l<span class="kw">;</span> <span class="kw">}</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="kw">function</span><span class="fu"> filetype_count</span> <span class="kw">{</span> <span class="fu">find</span> -name <span class="st">&quot;*.</span><span class="va">$1</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="fu">wc</span> -l<span class="kw">;</span> <span class="kw">}</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="fu">filetype_count()</span> <span class="kw">{</span> <span class="fu">find</span> -name <span class="st">&quot;*.</span><span class="va">$1</span><span class="st">&quot;</span> <span class="kw">|</span> <span class="fu">wc</span> -l<span class="kw">;</span> <span class="kw">}</span></a></code></pre></div>
</section>
<section id="pathname-expansion" class="slide level2">
<h2>Pathname expansion</h2>
<!--
Omdat Linux alles als een file ziet, zullen we vaak met bestandsnamen te maken hebben. We hebben de vorige les kennis gemaakt met globs (`*` en `?`), oftewel pathname-expansion. De `*` matcht iedere string, `?` een enkel karakter (niet meer, niet minder). In sommige gevallen wil je een karakter matchen met `?`, maar dit eigenlijk beperken tot een bepaalde set mogelijkheden. Hiervoor kun je de blokhaken gebruiken, met daarbinnen alle opties (of een range). `file[0-9]` zal `file0` matchen, `file1`, etc. tot `file9`.
Daarnaast kun je accolades en komma's gebruiken om met een set specifieke strings filenames te maken. De output van `echo file{1,2,3,4,5}` is _file1 file2 file3 file4 file5_. Ook hier kan je ranges gebruiken: het voorbeeld had ook als `echo file` mogelijkheden. Hiervoor kun je de blokhaken gebruiken, met daarbinnen alle opties (of een range). `file[0-9]` zal `file0` matchen, `file1`, etc. tot `file9`.
Daarnaast kun je accolades en komma's gebruiken om met een set specifieke strings filenames te maken. De output van `echo file{1,2,3,4,5}` is _file1 file2 file3 file4 file5_. Ook hier kan je ranges gebruiken: het voorbeeld had ook als `echo file{1..5}` gegeven kunnen worden.
-->
<aside class="notes">
<ul>
<li>matcht file met elke uitgang</li>
<li>matcht filea.zip, file1.zip, fileP.zip, etc</li>
<li>matcht alleen file0.zip tot file9.zip</li>
<li>matcht alleen fileN.zip en fileZ.zip</li>
<li>expand naar een de string “file.zip file.7z file.tbz file.rar}”</li>
<li>ranges ook toegestaan: <code>{1-5}</code></li>
</ul>
</aside>
<ul>
<li><code>file.*</code></li>
<li><code>file?.zip</code></li>
<li><code>file[0-9].zip</code></li>
<li><code>file[NZ].zip</code></li>
<li><code>file.{zip,7z,tbz,rar}</code></li>
</ul>
</section>
<section id="command-substitution" class="slide level2">
<h2>Command Substitution</h2>
<!--
Soms is het handig de uitvoer van een commando in een variabele te kunnen zetten, of als argument voor een ander commando te gebruiken. In veel gevallen is dit met pipes op te lossen, maar dat is niet altijd het geval. Gelukkig heeft Bash command substitution: een commando verpakt in `$( .. )` of `` `..` `` wordt door Bash uitgevoerd, waarna de uitvoer in de plaats van het commando komt. Beide notities zijn bruikbaar, al moet je met de haakjes-notatie uitkijken dat er geen verwarring ontstaat met haakjes die een andere betekenis hebben. De haakjes-notatie heeft wel als voordeel dat deze zich makkelijker laat nesten: met backticks moeten de binnenste backticks met een `\` gequote worden. De spaties bij de haakjes-notatie zijn niet verplicht, en vooral om de constructie `$((COMMAND))` te voorkomen teneinde het command in een subshell uit te voeren: de dubbele haakjes zijn namelijk ergens anders voor gereserveerd. In dit geval meot je dus `$( (COMMAND) )` gebruiken.
-->
<aside class="notes">
<ul>
<li>voer command uit en ga verder alsof de output er stond</li>
<li>zet datum in <code>$DATE</code></li>
<li>print de datum (datum naar echo dat input doorgeeft als output, naar nog een echo)</li>
<li>zelfde met backticks (let op de escaping)</li>
<li>dubbele haken (voor subshell binnen <code>$(..)</code>) moet met extra spaties, anders arithmetic expansion (volgende slide)</li>
</ul>
</aside>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="va">$(</span> <span class="ex">COMMANDS</span> <span class="va">)</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="kw">`</span><span class="ex">COMMANDS</span><span class="kw">`</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="va">DATE=$(</span><span class="fu">date</span><span class="va">)</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="bu">echo</span> <span class="va">$(</span><span class="bu">echo</span> <span class="va">$(</span><span class="fu">date</span><span class="va">))</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="bu">echo</span> <span class="kw">`</span><span class="bu">echo</span> <span class="dt">\`</span>date<span class="dt">\`</span><span class="kw">`</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="va">FOUT=$((</span>date<span class="va">))</span> <span class="co"># 0</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="va">BETER=$(</span> <span class="kw">(</span><span class="fu">date</span><span class="kw">)</span> <span class="va">)</span> <span class="co"># de datum</span></a></code></pre></div>
</section>
<section id="arithmetic-expansion-en-evaluation" class="slide level2">
<h2>Arithmetic Expansion en Evaluation</h2>
<!--
De reden dat we geen dubbele haakjes kunnen gebruiken bij command substitution is dat deze notatie gebruikt wordt voor arithmetic expansion (oftewel: rekenen). Arithmetic expansion geeft je de mogelijkheid een som op te geven, waarvan het antwoord op de plaats van de som komt te staan. De notatie hiervoor is `$((..))`.
Naast expansions hebben we ook arithmetic evaluations. Deze gebruiken we voor exnotessies waar het antwoord geen getal is, maar een _true_ of _false_. Deze kunnen we gebruiken in bijvoorbeeld een `if`-statement of een `while`- of `until`-loop. De notatie is `((..))`.
De meeste gebruikelijke rekenkundige operatoren, vergelijkingen en zelfs bitwise OR, AND en shifts zijn ondersteund; de gehele lijst is te vinden in de `man`-page van Bash.
-->
<aside class="notes">
<ul>
<li>Met dollar: reken uit tussen de haken</li>
<li>Meeste operatoren (inclusief bitwise or, and, shifts) mogelijk</li>
<li>Zonder dollar: gelijkheid, groter dan etc naar boolean voor if/while</li>
<li>Zie <code>man bash</code> voor mogelijke operatoren</li>
</ul>
</aside>
<div class="sourceCode" id="cb15"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="bu">echo</span> <span class="va">$((</span>6*7<span class="va">))</span> <span class="co"># 42</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="bu">read</span> -p <span class="st">&quot;Geef een getal: &quot;</span> <span class="va">getal</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="bu">echo</span> <span class="va">$(($getal</span>**2<span class="va">))</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="kw">if</span> <span class="kw">((</span><span class="va">$getal</span>**2 &gt; 100<span class="kw">))</span>; <span class="kw">then</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">  <span class="bu">echo</span> <span class="st">&quot;Het kwadraat van het getal was groter dan 100&quot;</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="kw">else</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  <span class="bu">echo</span> <span class="st">&quot;Het kwadraat van het getal was kleiner dan 100&quot;</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="kw">fi</span></a></code></pre></div>
</section>
<section id="lezen-van-de-command-line" class="slide level2">
<h2>Lezen van de command-line</h2>
<!--
Het commando `read` kan gebruikt worden om te lezen van de command-line (of, met `-u` uit een file). Standaard wordt een hele regel ingelezen, zodat je met een `while`-loop een hele file in kan lezen. Het resultaat wordt opgeslagen in variabelen waarvan de naam als argument moet worden meegegeven. `read foo` slaat de hele input op in `$foo`. Als er meerdere variabelen mee worden gegeven wordt het eerste woord in de eerste variabele opgeslagen, het tweede woord in de tweede, etc. De laatste variabele krijgt de rest van de input als er teveel woorden ingevoerd zijn. Als je geen variabelenaam meegeeft dan wordt `$REPLY` gebruikt.
Standaardopties voor `read` zijn `-p <PROMPT>` om eerst een prompt te printen, `-n <NUMMER>` om een gegeven aantal karakters te lezen, `-a <ARRAY>` om een array te gebruiken in plaats van normale variabelen, `-t <TIMEOUT>` voor een maximale wachttijd, en `-s` voor secure input (bash laat niet zien wat/dat er getypt wordt, zoals bij `sudo` het password-prompt).
-->
<aside class="notes">
<ul>
<li>lees command line en zet in $var</li>
<li>lees command line en zet woord 1 in $foo, woord 2 in $bar en rest in $baz</li>
<li>lees alles naar een array $ARRAY</li>
<li>lees 1 karakter in raw mode (-&gt; lees een enkele toetsaanslag)</li>
<li>lees binnen 15 sec een password (onzichtbaar typen) met een prompt</li>
</ul>
</aside>
<ul>
<li><code>read var</code></li>
<li><code>read foo bar baz</code></li>
<li><code>read -a ARRAY</code></li>
<li><code>read -n 1 -r</code></li>
<li><code>read -s -t 15 -p &quot;Say friend and enter: &quot; password</code></li>
</ul>
</section>
<section id="process-substitution" class="slide level2">
<h2>Process Substitution</h2>
<!--
Een laatste notatie die je in scripts tegen kan komen is die van process substitution. Hier wordt een pipe tussen twee processen vervangen door tijdelijk bestand, zodat een subshell voorkomen kan worden (en dus variabelen niet "kwijtraken" zodra de subshell verdwijnt). De syntax hiervoor is `<(COMMAND)`, waarbij de uitvoer van `COMMAND` in een tijdelijk bestand gezet wordt,dat automatisch verwijderd wordt zodra de inhoud niet meer nodig is.
-->
<aside class="notes">
<ul>
<li>alternatief voor pipes</li>
<li>werkt via files in <code>/dev/fd</code></li>
<li>file aangemaakt en automatisch verwijderd</li>
<li>student hoeft niet toe te passen, wel te herkennen</li>
<li>voorkomt de subshell die met een pipe gemaakt wordt</li>
<li>hierdoor raken geen variabelen kwijt in de subshell</li>
<li>zeldzaam</li>
</ul>
</aside>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="fu">uname</span> <span class="kw">|</span> <span class="fu">cat</span>    # Linux</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="fu">cat</span> <span class="op">&lt;(</span><span class="fu">uname</span><span class="op">)</span>   # Linux</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="bu">echo</span> <span class="op">&lt;(</span><span class="fu">find</span><span class="op">)</span>   # /dev/fd/63</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="fu">cat</span> <span class="op">&lt;</span> <span class="op">&lt;(</span><span class="fu">find</span><span class="op">)</span>  # Linux</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"><span class="bu">echo</span> <span class="op">&lt;</span> <span class="op">&lt;(</span><span class="fu">find</span><span class="op">)</span> <span class="co"># </span></a></code></pre></div>
</section>
<section id="precedentie" class="slide level2">
<h2>Precedentie</h2>
<aside class="notes">
<p>Van boven naar beneden belangrijkst naar minst</p>
</aside>
<!--
We hebben er inmiddels een hele tour van de Bash-shell opzitten. We hebben commando's gezien, die programma's kunnen zijn (e.g. `time`) of built-ins (e.g. `cd`). Daarnaast hebben we scripts en functies... Wat nou als we een functie `cd` maken, welke `cd` kiest Bash dan?
De keuze die Bash zal maken is bepaald door de precedentie van de verschillende soorten commands. Functies gaan altijd voor, dus bij het invoeren van een command kijkt Bash eerst of er een functie gedefiniëerd is. Zo niet, dan wordt naar built-ins gekeken. Als die er ook niet is, dan wordt het `$PATH` doorzocht. De eerste map waar een script of programma met dezelfde naam als het gevraagde commando te vinden is, wordt gekozen.
-->
<ul>
<li>Function</li>
<li>Built-in</li>
<li>Program / Script (via <code>PATH</code>)</li>
</ul>
</section>
<section id="profiling" class="slide level2">
<h2>Profiling</h2>
<aside class="notes">
<ul>
<li>zien hoe snel je script draait</li>
<li>of een command daarin</li>
<li>totale tijd (op de klok)</li>
<li>tijd proces daadwerkelijk aan de beurt
<ul>
<li>in user space</li>
<li>in syscalls / kernel space</li>
</ul></li>
</ul>
</aside>
<!--
Soms wil je weten hoe lang je script gedraaid heeft, of hoe lang een commando binnen je script duurt. Linux heeft hiervoor het `time` commando. Deze geeft drie tijden terug: hoe lang het duurde tot het proces daadwerkelijk klaar was, hoeveel tijd het proces aan de beurt is geweest in user mode, en hoe lang de kernel voor het proces bezig is geweest.
-->
<div class="sourceCode" id="cb17"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="bu">time</span> ./myScript</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="co"># real    0m4.743s</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="co"># user    0m0.957s</span></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="co"># sys     0m1.948s</span></a></code></pre></div>
</section>
<section id="wat-hebben-we-deze-les-geleerd" class="slide level2">
<h2>Wat hebben we deze les geleerd?</h2>
<ul>
<li>Bash scripts</li>
<li>Flow control</li>
<li>Functies</li>
<li>Expansions &amp; Substitutions</li>
</ul>
</section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
