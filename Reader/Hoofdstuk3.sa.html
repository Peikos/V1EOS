<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Hoofdstuk3</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p>Deze les gaan we de Linux command line verkennen. We maken kennis met Bash, de meest gangbare shell voor Linux. Ook komen we een diversiteit aan programma’s tegen die we vanaf de command line kunnen gebruiken. Het is in Bash niet altijd duidelijk welk commando een “built-in” functie van Bash is, en welk command een programma is: omdat Bash gebruikt wordt om programma’s aan elkaar te knopen is deze grens behoorlijk vervaagd. Deze kennis is meestal ook niet nodig om Bash te gebruiken, maar wel iets om in het achterhoofd te houden.</p>
<h1 id="je-weg-vinden-op-de-command-line">Je weg vinden op de command-line</h1>
<p>Als je een nieuwe terminal start, heeft je shell standaard een working directory: het punt op het filesysteem waar je je bevindt. Bestanden die je maakt worden in deze map gezet, en bestanden die je zoekt kunnen relatief vanaf deze map benaderd worden. Standaard zul je beginnen in je <em>home</em> directory, de map die je als gebruiker zelf beheert en waar je eigen bestanden (en instellingen) te vinden zijn. Het commando <code>cd</code> (change directory) wordt gebruikt om van map te wisselen, en <code>pwd</code> (present working directory) vertelt waar je je nu bevindt. Met <code>ls</code> (list) kun je de inhoud van de huidige map te zien krijgen. Een aantal paden zijn belangrijk om te weten: de bovenste directory, de root directory, wordt met een <code>/</code> (slash) aangeduid. Vanaf hier worden directory-namen door een <code>/</code> gescheiden om een pad uit te drukken. De home directory van de gebruiker <code>jon</code> bevindt zich bijvoorbeeld op <code>/home/jon</code> (de map <code>jon</code>, binnen de map <code>home</code>, binnen de root). <code>~</code> wordt gebruikt als synoniem voor de home directory van de huidige gebruiker. Voor Jon is <code>cd ~</code> dus hetzelfde als <code>cd /home/jon</code>. <code>.</code> verwijst naar de huidige map: <code>cd .</code> doet niets. Dit kan voor nu een beetje overbodig lijken, maar later zullen we zien hoe de <code>.</code> soms korter is dan de alternatieven. Daarnaast hebben we <code>..</code>, die naar de parent van de huidige directory verwijst. Vanaf Jon’s home zal <code>cd ..</code> dus naar <code>/home</code> verwijzen. Deze kun je ook middenin een pad gebruiken, de map omhoog wordt dan gerekend vanaf waar in het pad deze wordt gebruikt. <code>cd /home/jon/Documents/../Music</code> is bijvoorbeeld hetzelfde als <code>cd /home/jon/Music</code>. <code>cd</code> zonder argument gaat terug naar de home directory, en <code>cd -</code> gaat terug naar de vorige directory.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~]$ cd Documents</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">[<span class="ex">jon@Snow</span>:~/Documents]$ pwd</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ex">/home/jon/Documents</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">[<span class="ex">jon@Snow</span>:~/Documents]$ cd ..</a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">[<span class="ex">jon@Snow</span>:~]$ cd Folder</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="ex">AnotherFile</span>  File</a>
<a class="sourceLine" id="cb1-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">[<span class="ex">jon@Snow</span>:~/Folder]$ cd ~</a>
<a class="sourceLine" id="cb1-14" data-line-number="14"></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">[<span class="ex">jon@Snow</span>:~]$ cd -</a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="ex">/home/jon/Folder</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">[<span class="ex">jon@Snow</span>:~/Folder]$ cd .</a>
<a class="sourceLine" id="cb1-19" data-line-number="19"></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">[<span class="ex">jon@Snow</span>:~/Folder]$ cd /</a>
<a class="sourceLine" id="cb1-21" data-line-number="21"></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">[<span class="ex">jon@Snow</span>:/]$ ls</a>
<a class="sourceLine" id="cb1-23" data-line-number="23"><span class="ex">bin/</span>  boot/  dev/  etc/  home/  media/  mnt/  proc/  root/  run/  sys/  tmp/  usr/  var/</a>
<a class="sourceLine" id="cb1-24" data-line-number="24"></a>
<a class="sourceLine" id="cb1-25" data-line-number="25">[<span class="ex">jon@Snow</span>:/]$ cd</a>
<a class="sourceLine" id="cb1-26" data-line-number="26"></a>
<a class="sourceLine" id="cb1-27" data-line-number="27">[<span class="ex">jon@Snow</span>:~]$ pwd</a>
<a class="sourceLine" id="cb1-28" data-line-number="28"><span class="ex">/home/jon</span></a></code></pre></div>
<p>De volgende commando’s manupileren bestanden. Met <code>touch</code> wordt een bestand aangemaakt (als deze nog niet bestond) of wordt de “laatst aangepast” datum naar nu gezet. Het bestand wordt gewijzigd, maar er verandert niets aan. Met <code>cp</code> kun je een bestand kopiëren, en met <code>mv</code> kun je het verplaatsen. <code>rm</code> verwijdert een bestand.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ex">AnotherFile</span>  File</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">[<span class="ex">jon@Snow</span>:~/Folder]$ touch File3</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="ex">AnotherFile</span>  File  File3</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">[<span class="ex">jon@Snow</span>:~/Folder]$ cp File File2</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="ex">AnotherFile</span>  File  File2  File3</a>
<a class="sourceLine" id="cb2-13" data-line-number="13"></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">[<span class="ex">jon@Snow</span>:~/Folder]$ mv AnotherFile File1</a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb2-17" data-line-number="17"><span class="ex">File</span>  File1  File2  File3</a>
<a class="sourceLine" id="cb2-18" data-line-number="18"></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">[<span class="ex">jon@Snow</span>:~/Folder]$ rm File3</a>
<a class="sourceLine" id="cb2-20" data-line-number="20"></a>
<a class="sourceLine" id="cb2-21" data-line-number="21">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb2-22" data-line-number="22"><span class="ex">File</span>  File1  File2</a></code></pre></div>
<p>De meeste commando’s voor bestanden werken niet direct op directories. <code>mv</code> mag, maar <code>cp</code> en <code>rm</code> werken niet. Voor het verwijderen van een <em>lege</em> map wordt <code>rmdir</code> gebruikt, maar dit mag niet als er een bestand in de map zit. Dit is omdat Linux je wil beschermen geen verkeerde handeling uit te voeren: als je aangeeft dat je een bestand wil verwijderen, maar je geeft een map op, dan is de kans groot dat je de verkeerde naam hebt meegegeven. Als je toch een map (met alle inhoud) wilt kopiëren of verwijderen, kun je <code>cp -r</code> en <code>rm -r</code> gebruiken. De toevoeging <code>-r</code> staat voor <em>recursief</em> (dat betekent in dit geval: met alles wat eronder hangt). Gebruik bijvoorbeeld <code>rm -r Music</code> als je de map Music met alle inhoud wil verwijderen. <code>-r</code> is het eerste voorbeeld van een flag.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ex">File</span>  File1  File2</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">[<span class="ex">jon@Snow</span>:~/Folder]$ mkdir Subfolder</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">[<span class="ex">jon@Snow</span>:~/Folder]$ touch Subfolder/File</a>
<a class="sourceLine" id="cb3-7" data-line-number="7"></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">[<span class="ex">jon@Snow</span>:~/Folder]$ mkdir EmptyFolder</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="ex">EmptyFolder/</span>  File  File1  File2  Subfolder/</a>
<a class="sourceLine" id="cb3-12" data-line-number="12"></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">[<span class="ex">jon@Snow</span>:~/Folder]$ mkdir EmptyFolder2</a>
<a class="sourceLine" id="cb3-14" data-line-number="14"></a>
<a class="sourceLine" id="cb3-15" data-line-number="15">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb3-16" data-line-number="16"><span class="ex">EmptyFolder/</span>  EmptyFolder2/  File  File1  File2  Subfolder/</a>
<a class="sourceLine" id="cb3-17" data-line-number="17"></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">[<span class="ex">jon@Snow</span>:~/Folder]$ rmdir EmptyFolder</a>
<a class="sourceLine" id="cb3-19" data-line-number="19"></a>
<a class="sourceLine" id="cb3-20" data-line-number="20">[<span class="ex">jon@Snow</span>:~/Folder]$ rmdir Subfolder</a>
<a class="sourceLine" id="cb3-21" data-line-number="21"><span class="ex">rmdir</span>: failed to remove <span class="st">&#39;Subfolder/&#39;</span>: Directory not empty</a>
<a class="sourceLine" id="cb3-22" data-line-number="22"></a>
<a class="sourceLine" id="cb3-23" data-line-number="23">[<span class="ex">jon@Snow</span>:~/Folder]$ cp Subfolder Backup</a>
<a class="sourceLine" id="cb3-24" data-line-number="24"><span class="ex">cp</span>: -r not specified<span class="kw">;</span> <span class="ex">omitting</span> directory <span class="st">&#39;Subfolder&#39;</span></a>
<a class="sourceLine" id="cb3-25" data-line-number="25"></a>
<a class="sourceLine" id="cb3-26" data-line-number="26">[<span class="ex">jon@Snow</span>:~/Folder]$ cp -r Subfolder Backup</a>
<a class="sourceLine" id="cb3-27" data-line-number="27"></a>
<a class="sourceLine" id="cb3-28" data-line-number="28">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb3-29" data-line-number="29"><span class="ex">Backup/</span>  EmptyFolder2/  File  File1  File2  Subfolder/</a>
<a class="sourceLine" id="cb3-30" data-line-number="30"></a>
<a class="sourceLine" id="cb3-31" data-line-number="31">[<span class="ex">jon@Snow</span>:~/Folder]$ rm -r Subfolder</a>
<a class="sourceLine" id="cb3-32" data-line-number="32"></a>
<a class="sourceLine" id="cb3-33" data-line-number="33">[<span class="ex">jon@Snow</span>:~/Folder]$ rm -r EmptyFolder2</a>
<a class="sourceLine" id="cb3-34" data-line-number="34"></a>
<a class="sourceLine" id="cb3-35" data-line-number="35">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb3-36" data-line-number="36"><span class="ex">Backup/</span>  File  File1  File2</a></code></pre></div>
<h2 id="flags-command-line-arguments">Flags / Command Line Arguments</h2>
<p>De meeste commando’s accepteren command line argumenten. Allereerst zijn er verplichte argumenten. Waar <code>pwd</code> bijvoorbeeld geen argumenten nodig heeft, heeft <code>touch</code> enkel zin als meegegeven wordt welk bestand gemaakt of geüpdatet moet worden. <code>cp</code> heeft zelfs twee argumenten nodig: een bron en een doel. Soms kan een commando een optioneel pad meekrijgen: <code>ls</code> werkt in de huidige working directory, <code>ls /home</code> leest de inhoud van <code>/home</code>. Al deze argumenten zijn positie-bepaald. Het eerste argument bij <code>cp</code> is altijd de bron, de tweede het doel. Naast deze positiegebonden argumenten hebben we ook flags, die met één of twee streepjes (dashes) kunnen beginnen. Flags komen doorgaans overeen met booleaanse waardes: wel of niet. Als de flag met één dash begint, dan is het doorgaans een enkele letter, en kun je deze combineren. <code>-r -f</code> is hetzelfde als <code>-rf</code>; het maakt niet uit of je <code>rm -r -f Music</code> gebruikt of het kortere <code>rm -rf Music</code>. Ook de volgorde maakt meestal niet uit. Flags met een dubbele dash bestaan uit meerdere letters en zijn niet samen te voegen. Tot slot kunnen deze flags soms een argument erbij nemen. Bij enkele letters volgt het argument meestal na een (optionele) spatie, bij de dubbele dash wordt meestal een <code>=</code> gebruikt om de waarde van de flag te scheiden.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">File</span>  File1  File2  Folder1/  Folder2/ Folder3/</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">[<span class="ex">jon@Snow</span>:~/Folder]$ rm -r Folder1    # Recursive om directory te deleten</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">[<span class="ex">jon@Snow</span>:~/Folder]$ rm -f File2      # Force remove</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">[<span class="ex">jon@Snow</span>:~/Folder]$ rm -r -f Folder2 <span class="co"># Force recursive remove</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">[<span class="ex">jon@Snow</span>:~/Folder]$ rm -rf Folder3   # Zelfde als -r -f</a>
<a class="sourceLine" id="cb4-11" data-line-number="11"></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">[<span class="ex">jon@Snow</span>:~/Folder]$ rm --force File1 <span class="co"># Zelfde als -f</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14">[<span class="ex">jon@Snow</span>:~/Folder]$ ls</a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="ex">File</span></a></code></pre></div>
<div style="float:right; max-width:25vw; padding: 10px;">
<p><img style="max-width: 30vh;" src="https://peikos.net/V1EOS/Images/rtfm.png"></p>
</div>
<p>Sommige commando’s hebben erg veel opties om de gewenste functionaliteit te selecteren. De meeste commando’s hebben een <code>-h</code> en/of <code>--help</code> optie om wat tips te geven over het gebruik. Voor het hele verhaal kun je <code>man</code> gebruiken, oftewel de manual.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~]$ rm --help</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co"># Print een (relatief) korte handleiding</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">[<span class="ex">jon@Snow</span>:~]$ man rm</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="co"># Scroll door de uitgebreide handleiding</span></a></code></pre></div>
<h2 id="io-en-pipes">IO en Pipes</h2>
<p>Om een tree te krijgen van de inhoud van een map en alle submappen kun je het commando <code>find</code> gebruiken. Dit geeft echter vrij veel uitvoer, het zou fijn zijn als we hier hapklare brokken van konden maken. Het commando <code>less</code> kan gebruikt worden om een bestand te openen en er doorheen te kunnen scrollen. Kunnen we dit gebruiken om de uitvoer van <code>find</code> te pagineren? In Linux kun je twee commando’s aan elkaar koppelen: uitvoer van het ene programma wordt als invoer voor het tweede gebruikt. Hiervoor gebruiken we het <code>|</code> symbool: de pipe. Denk aan een pijpleiding die de commando’s met elkaar verbindt.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~]$ find /home/jon</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="co"># Print de hele mappenstructuur; veel output</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">[<span class="ex">jon@Snow</span>:~]$ less file</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="co"># Lees een bestand door er doorheen te scrollen</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7">[<span class="ex">jon@Snow</span>:~]$ find /home/jon <span class="kw">|</span> <span class="fu">less</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="co"># Combineer de tools: scroll door de uitvoer van find</span></a></code></pre></div>
<h3 id="sys_pipe"><code>SYS_pipe</code></h3>
<p>Pipes zijn een fundamenteel onderdeel van de Unix filosofie om eenvoudige programma’s te combineren voor complex gedrag. De pipe is dermate belangrijk dat hiervoor een speciale system call bestaat: <code>SYS_pipe</code>. Hieronder zien we de stappen die de shell doorloopt bij het uitvoeren van een <code>find | less</code>.</p>
<ol type="1">
<li>Shell maakt een pipe met <code>pipe()</code></li>
<li>Shell <code>fork</code>t twee keer</li>
<li>Child 1 stuurt uitvoer naar pipe</li>
<li>Child 2 leest invoer uit pipe</li>
<li>Child 1 roept <code>exec()</code> aan met <code>find</code></li>
<li>Child 2 roept <code>exec()</code> aan met <code>less</code></li>
<li>Parent wacht tot beide children <code>exit</code>en</li>
</ol>
<!-- TODO
## Details Pipes
::: notes
Op deze slide zien we een pipe zoals deze in de shell geïmplementeerd is. Hiervoor introduceren we een nieuwe syscall: `SYS_pipe`
:::
``` bash
int fd[2]; pipe(fd);
int pid1 = fork(); if (pid1 == 0)
{ close(fd[0]);
  execv("/bin/find", args1); }
else
{ int pid2 = fork(); if (pid2 == 0)
  { close(fd[1]);
    execv("/bin/less", args2); }
  else
  { close(fd[0]); close(fd[1]);
    wait(pid2); }
  wait(pid1); }
```
-->
<h3 id="stdin-en-stdout"><code>STDIN</code> en <code>STDOUT</code></h3>
<p>Het sturen van de uitvoer noemen we het <em>redirecten</em> van <code>STDOUT</code> (standard out), en het lezen van de invoer is het <em>redirecten</em> van <code>STDIN</code> (standard in). Dit hoeft niet met een pipe te gebeuren, maar kan ook van/naar een bestand. <code>STDOUT</code> is een file descriptor (nummer 1) die in ieder proces aanwezig is, en die gebruikt wordt om alles naartoe te schrijven dat het programma uitvoert (denk aan <code>print</code>s). <code>STDIN</code> is ook een file descriptor (nummer 0), maar deze wordt gelezen voor invoer. Normaal is dit de gebruikersinvoer vanaf de command line, maar dit kan ook prima een bestand of pipe zijn. Daarnaast is er vaak een derde file descriptor, <code>STDERR</code> (standard error, nummer 2), voor foutmeldingen (ook dit is standaard de command line, maar het is hiermee dus mogelijk te splitsen tussen uitvoer en excepties). Het gebruik van file descriptors voor de invoer/uitvoer is weer een voorbeeld van de UNIX-filosofie dat alles een bestand is. Een descriptor is de datastructuur die UNIX intern gebruikt om iets te kunnen benaderen; een file descriptor verwijst dus naar een bestand (en hoe dit gelezen/geschreven kan worden). Waar <code>STDIN</code> en <code>STDOUT</code> precies aan verbonden zijn, is te vinden in de environment informatie die bij een proces hoort. Standaard zijn dit voor processen die je in de shell start de invoer en de uitvoer van de terminal, en als je een child process start worden deze overgeërfd. Tijdens executie van het proces kunnen deze descriptors altijd ergens anders aan verbonden worden, maar de <code>STDIN</code> en <code>STDOUT</code> moeten altijd ergens naar verwijzen. Bij processen die door de kernel gestart worden, zoals <code>init</code> is de <code>STDOUT</code> doorgaans aan het kernel log gekoppeld. <code>STDIN</code> kan aan een buffer of (als het proces geen input verwacht) aan een dummy file gekoppeld zijn: een lege file descriptor die niet aan een daadwerkelijk bestand op de schijf gekoppeld is.</p>
<div id="fig:io">
<figure>
<img src="https://peikos.net/V1EOS/Images/io.png" alt="Figuur: File Descriptors van een Proces" style="width:40.0%" /><figcaption>Figuur: File Descriptors van een Proces</figcaption>
</figure>
</div>
<h3 id="io-redirection">IO Redirection</h3>
<p>Net als dat we vanaf de shell twee commando’s aan elkaar kunnen pipen, kunnen we ook een file descriptor meegeven om als <code>STDIN</code>, <code>STDOUT</code> of <code>STDERR</code> te gebruiken. Dit kan respectievelijk met <code>&lt;</code>, <code>&gt;</code> en <code>2&gt;</code>. Je kunt bijvoorbeeld <code>find /home/jon &gt; filetree</code> gebruiken om de uitvoer van <code>find /home/jon</code> in het bestand <code>filetree</code> te schrijven. Bij <code>find /home/jon 2&gt; errors.log</code> wordt niet de uitvoer verbonden, maar eventuele foutmeldingen via <code>STDERR</code>. Als het bestand waarnaar je wilt uitvoeren al bestaat, wordt het als je <code>&gt;</code> gebruikt overschreven, maar je kunt, <code>&gt;&gt;</code> en <code>2&gt;&gt;</code> gebruiken om in plaats daarvan achteraan het bestand toe te voegen. Tot slot kun je <code>&lt;&lt; MARKER</code> of <code>&lt;&lt;- MARKER</code> (een zogenaamde “heredoc”) gebruiken om <code>STDIN</code> vanaf de command line mee te geven, tot aan de eerste regel met enkel <code>MARKER</code>. Dit maakt het makkelijk meerdere regels tekst mee te geven. De toegevoegde waarde van de <code>-</code> is dat deze een tab aan het begin van een regel negeert en mogelijk leesbaarder is. Op zichzelf wordt <code>&lt;</code> niet zo veel gebruikt, omdat de meeste programma’s standaard een meegegeven bestandsnaam als <code>STDIN</code> interpreteren (dus <code>less &lt; file</code> is hetzelfde als <code>less file</code>), maar bij sommige programma’s kan dit nodig zijn. Een voorbeeld is <code>psql</code>, een database waarbij je een bestand met instructies mee kan geven met <code>psql databasename &lt; sqlfile</code>. Als je <code>&lt;</code> niet gebruikt en vanaf de command line invoert kun je <code>Control-d</code> gebruiken om je invoer te beëindigen, in plaats van de explicete <code>MARKER</code> die je bij <code>&lt;&lt;</code> gebruikt. <code>wc</code> staat trouwens voor <em>word count</em>, waarbij <code>wc -l</code> het aantal regels telt, en <code>wc -c</code> het aantal karakters.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~]$ find /home/jon <span class="op">&gt;</span> filetree <span class="op">2&gt;</span> errors.log</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co"># Geen output; alles staat in bestanden filetree en errorslog</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">[<span class="ex">jon@Snow</span>:~]$ wc -l filetree <span class="op">&gt;&gt;</span> filetree</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="co"># Het totaal aantal regels in filetree wordt onderaan filetree toegevoegd</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">[<span class="ex">jon@Snow</span>:~]$ wc -c <span class="op">&lt;&lt; EOF</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">&gt; Lorem Ipsum</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">&gt; Dolor Sit Amet</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">&gt; EOF</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">27</a>
<a class="sourceLine" id="cb7-12" data-line-number="12"></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">[jon@Snow:~]$ psql databasename &lt; sqlfile</a>
<a class="sourceLine" id="cb7-14" data-line-number="14"># Laadt een database uit een file</a></code></pre></div>
<p>Hier zien we hoe redirection er vanuit het shell proces uit ziet. Als voorbeeld gebruiken we het commando <code>command a1 a2 &lt; in_file &gt; out_file 2&gt; /dev/null</code>: <code>/dev/null</code> is een speciaal virtueel device, waar altijd naar geschreven kan worden. <code>/dev/null</code> gedraagt zich als een zwart gat: alles dat ernaar geschreven wordt verdwijnt. In dit geval onderdrukken we dus error messages door alle <code>STDERR</code> uitvoer naar de prullenbak te verwijzen. Zowel <code>&lt; in_file</code> als <code>&gt; out_file</code> en <code>2&gt; /dev/null</code> hebben invloed op het commando <code>command a1 a2</code>, en worden niet onderling met elkaar verbonden anders dan via het <code>command a1 a2</code>-proces. Merk op dat bestanden in Linux lang niet altijd een extensie hebben (zoals <code>.txt</code> of <code>.doc</code>). Linux bepaalt aan de hand van de inhoud met wat voor type bestand het te maken heeft. In dit geval zijn <code>in_file</code> en <code>out_file</code> waarschijnlijk tekstbestanden.</p>
<ol type="1">
<li>De shell <code>fork</code>t</li>
<li>Child sluit <code>STDIN</code> en opent <code>in_file</code> als <code>STDIN</code></li>
<li>Child sluit <code>STDOUT</code> en opent <code>out_file</code> als <code>STDOUT</code></li>
<li>Child sluit <code>STDERR</code>, opent <code>/dev/null</code> als <code>STDERR</code></li>
<li>Child roept <code>exec()</code> aan met <code>command</code> en geeft <code>a1 a2</code> als argumenten mee</li>
<li>Parent wacht tot het kind <code>exit</code></li>
</ol>
<h2 id="meer-commandos-met-pipes">Meer Commando’s met Pipes</h2>
<p>Nu we het bestaan van pipes kennen, zijn hier nog wat commando’s die op zichzelf niet altijd even zinvol zijn, maar als deel van een pipeline goed werken. Om uit bestand (of uitvoer) regels te filteren die een bepaalde string bevatten kun je <code>grep</code> gebruiken. <code>sort</code> geeft de invoer gesorteerd terug, en <code>cut</code> snijdt per regel een substring uit. In het onderste voorbeeld wordt <code>ls -l</code> gebruikt (een directory listing met uitgebreide info). We gebruiken <code>cut -c14-</code> om karakter 14 tot eind te bewaren, waardoor de eigenaar van het bestand vooraan komt te staan. Met <code>sort</code> kunnen we hierop sorteren.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~/Folder]$ ls -la</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ex">total</span> 0</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ex">drwxr-xr-x</span> 1 jon users   44 Jan 28 10:10 .</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ex">drwx------</span> 1 jon users 6142 Jan 28 10:05 ..</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ex">-rw-r--r--</span> 1 root   users    0 Jan 28 09:46 File</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="ex">-rw-r--r--</span> 1 jon users    0 Jan 28 10:08 File2</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ex">-rw-r--r--</span> 1 jon users    0 Jan 28 10:08 File2018</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="ex">-rw-r--r--</span> 1 jon users    0 Jan 28 10:08 File3</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">[<span class="ex">jon@Snow</span>:~/Folder]$ ls -la <span class="kw">|</span> <span class="fu">grep</span> 2018</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="ex">-rw-r--r--</span> 1 jon users 0 Jan 28 10:08 File2018</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">[<span class="ex">jon@Snow</span>:~/Folder]$ ls -la <span class="kw">|</span> <span class="fu">cut</span> -c14- <span class="kw">|</span> <span class="fu">sort</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14"></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="ex">jon</span> users    0 Jan 28 10:08 File2</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"><span class="ex">jon</span> users    0 Jan 28 10:08 File2018</a>
<a class="sourceLine" id="cb8-17" data-line-number="17"><span class="ex">jon</span> users    0 Jan 28 10:08 File3</a>
<a class="sourceLine" id="cb8-18" data-line-number="18"><span class="ex">jon</span> users   44 Jan 28 10:10 .</a>
<a class="sourceLine" id="cb8-19" data-line-number="19"><span class="ex">jon</span> users 6142 Jan 28 10:05 ..</a>
<a class="sourceLine" id="cb8-20" data-line-number="20"><span class="ex">root</span>   users    0 Jan 28 09:46 File</a></code></pre></div>
<h2 id="pipelines-en-command-lists">Pipelines en Command-lists</h2>
<p>Meerdere commands gescheiden door pipes vormen samen een pipeline. De commando’s worden parallel uitgevoerd. Je kunt ook meerdere commands na elkaar uit laten voeren, dit kan met de puntkomma en wordt een command-list genoemd. Het is zelfs mogelijk meerdere pipelines in een command list te zetten.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~]$ foo <span class="kw">|</span> <span class="ex">bar</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co"># De uitvoer van foo gaat naar bar</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">[<span class="ex">jon@Snow</span>:~]$ foo <span class="kw">;</span> <span class="ex">bar</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="co"># bar wordt na foo uitgevoerd</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">[<span class="ex">jon@Snow</span>:~]$ foo <span class="kw">|</span> <span class="ex">bar</span> <span class="kw">;</span> <span class="ex">baz</span> <span class="kw">|</span> <span class="ex">quux</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="co"># Eerst worden foo en bar uitgevoerd, waarbij de uitvoer van foo naar bar gaat</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="co"># Als dit klaar is worden baz en quux gestart, en gaat de uitvoer van baz naar quux</span></a></code></pre></div>
<p>Commands in een command list worden na elkaar uitgevoerd, ongeacht of er ergens iets mis gaat. Soms wil je het tweede command enkel uitvoeren als het eerste command geslaagd is, of juist alleen als er een fout is geweest. Zoals we weten heeft ieder command een exit status, <code>0</code> voor succes of iets anders voor een fout. Door <code>&amp;&amp;</code> tussen commands te zetten, in plaats van <code>;</code> wordt het tweede commando alleen uitgevoerd als het eerste geslaagd is. De dubbele pipe <code>||</code> werkt precies andersom: het tweede command wordt alleen uitgevoerd als de eerste mislukte. We noemen deze operators <em>en</em> en <em>of</em>. “Doe a en b” kan alleen maar als <em>a</em> gelukt is, zo niet zal de shell het meteen opgeven. “Doe a of b” levert de shell een alternatief, probeer eerst <em>a</em>, en als dat niet lukt, doe dan <em>b</em>. ::: end study</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~]$ foo <span class="kw">||</span> <span class="ex">bar</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co"># bar wordt uitgevoerd als foo faalt</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">[<span class="ex">jon@Snow</span>:~]$ foo <span class="kw">&amp;&amp;</span> <span class="ex">bar</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="co"># bar wordt uitgevoerd als foo gelukt is</span></a></code></pre></div>
<h2 id="procesmanagement">Procesmanagement</h2>
<p>Als je wilt weten welke processen er op dit moment actief zijn kun je het commando <code>ps</code> gebruiken. Normaal geeft dit alleen een lijst met je eigen processen in terminals, maar met <code>ps -A</code> krijg je alle processen te zien. De standaarduitvoer geeft (afhankelijk van je distributie) in ieder geval de PID, terminal en het command. Vaak wordt ook de effectieve tijd die het proces gedraaid heeft meegegeven (effectieve tijd telt alleen de tijd dat het proces daadwerkelijk actief was). Daarnaast heeft <code>ps</code> nog heel veel opties om processen te selecteren en aan te geven welke informatie je wel en niet wil hebben, zie daarvoor de <code>man</code> pagina. <code>ps</code> geeft een eenmalige uitvoer van de processenlijst op dat moment; dit is handig als je dit met andere commands in een pipeline wil combineren. Soms wil je echter een dynamische lijst die zichzelf update, zoals het taakbeheer in Windows. Hier is het commando <code>top</code> voor, of de verbeterde versie <code>htop</code> (meestal niet standaard geïnstalleerd). Tot slot kan je een proces vanaf de command line beëindigen (op voorwaarde dat je zelf de eigenaar van het proces bent). Hiervoor gebruik je <code>kill</code> met de PID van het proces, of <code>killall</code> met de naam van het proces. De laatste heet killall, omdat het goed kan zijn dat je meerdere instanties van dezelfde executable open hebt staan. <code>killall firefox</code> sluit bijvoorbeeld alle Firefox vensters, niet een specifieke.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~]$ ps</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="co"># geef de processen binnen de huidige shell</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">[<span class="ex">jon@Snow</span>:~]$ ps -A</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="co"># geef alle processen</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">[<span class="ex">jon@Snow</span>:~]$ top</a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="co"># interactieve &quot;task manager&quot;</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">[<span class="ex">jon@Snow</span>:~]$ kill</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="co"># stop een proces met een gegeven PID</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">[<span class="ex">jon@Snow</span>:~]$ killall</a>
<a class="sourceLine" id="cb11-14" data-line-number="14"><span class="co"># stop elk proces met een gegeven naam</span></a></code></pre></div>
<h2 id="signals">Signals</h2>
<p><code>kill</code> en <code>killall</code> zullen standaard een <code>SIGTERM</code> signaal naar een proces sturen: een vriendelijk doch dringend verzoek om op te houden te bestaan. Dit betekent dat het proces de gelegenheid heeft achter zich op te ruimen, de gebruiker te vragen of zij de wijzigingen op wil slaan, of het verzoek te negeren. Er bestaan echter meerdere signalen die je kan sturen, de belangrijksten staan in de tabel op deze slide. Om bijvoorbeeld een <code>SIGKILL</code> signaal te versturen (om een proces direct en <em>with extreme prejudice</em> om zeep te helpen) kan dit met <code>kill -SIGKILL</code>. <code>SIGSTOP</code> pauzeert een proces, dat met <code>SIGCONT</code> weer hervat kan worden. In de tussentijd is het proces bevroren, en zal het niet gescheduled worden. Een GUI applicatie zal wel een scherm behouden, maar nergens meer op reageren tot het een <code>SIGCONT</code> ontvangt. De tabel met beschikbare signalen is groot, en bevat ook signalen die normaal alleen voor intern gebruik zijn: <code>SIGSEGV</code> wordt bijvoorbeeld door de kernel gestuurd als een proces buiten zijn geheugenruimte opereert (een Segmentation Fault), en <code>SIGFPE</code> wordt onder andere door de CPU gestuurd naar een proces dat door 0 probeert te delen. De hele tabel is in de Linux documentatie of op internet te vinden. De getallen zijn de interne waardes die het OS herkent, de namen zijn enkel om het de gebruiker makkelijker te maken.</p>
<table>
<tbody>
<tr class="odd">
<td>SIGKILL(9)</td>
<td>Proces beëindigen, kan niet afgevangen worden</td>
</tr>
<tr class="even">
<td>SIGUSR1(10)</td>
<td>User defined, verschilt per programma</td>
</tr>
<tr class="odd">
<td>SIGTERM(15)</td>
<td>Standaard signaal, “sterf, alsjeblieft”</td>
</tr>
<tr class="even">
<td>SIGCONT(18)</td>
<td>Hervat een gestopt (gepauseerd) proces</td>
</tr>
<tr class="odd">
<td>SIGSTOP(19)</td>
<td>Stop tot je een SIGCONT krijgt</td>
</tr>
</tbody>
</table>
<h2 id="fore--en-background-jobs">Fore- en Background jobs</h2>
<p>Doorgaans zal een shell bij het uitvoeren van een command een <code>fork()</code> en een <code>exec()</code> uitvoeren, waarna de parent <code>wait()</code> tot het kind klaar is. Met behulp van de enkele ampersand (<code>&amp;</code>) kunnen we een proces op de achtergrond starten: de shell wacht niet en geeft meteen een nieuw prompt aan de gebruiker. Het nieuwe proces is nog steeds een kind van de shell, en als de shell beëindigd wordt voor het kind klaar is wordt dit ook getermineerd. Met <code>Control-z</code> kun je het huidige foreground proces (het proces waarop de shell aan het wachten is) een <code>SIGSTOP</code> sturen, waarna de shell weer op de gebruiker kan reageren. Met <code>fg</code> krijgt het proces een <code>SIGCONT</code> en hervat het de claim op de shell: het wordt naar de voorgrond gestuurd. Je kunt echter ook <code>bg</code> gebruiken om het proces op de achtergrond door te laten gaan, net alsof het met een <code>&amp;</code> gestart was. <code>jobs</code> geeft een lijst met actieve achtergrond processen. Als je een shell met actieve achtergrondprocessen probeert te beëindigen krijg je meestal een waarschuwing: als de terminal sluit stoppen de processen ook. Om dit te voorkomen kun je het proces met <code>disown</code> onterven: het is niet langer een kind van de shell waar het gestart is, maar wordt onder het <em>init</em> proces gehangen.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~]$ python3</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ex">Python</span> 3.6.6 (default, Jun 27 2018, 05:47:41) </a>
<a class="sourceLine" id="cb12-3" data-line-number="3">[<span class="ex">GCC</span> 7.3.0] on linux</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="ex">Type</span> <span class="st">&quot;help&quot;</span>, <span class="st">&quot;copyright&quot;</span>, <span class="st">&quot;credits&quot;</span> or <span class="st">&quot;license&quot;</span> for more information.</a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="op">&gt;&gt;&gt;</span> <span class="ex">antwoord</span> = 42</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="op">&gt;&gt;&gt;</span> </a>
<a class="sourceLine" id="cb12-7" data-line-number="7">[<span class="ex">1</span>]+  Stopped                 python3                  # Python gepauzeerd (<span class="st">&quot;Stopped&quot;</span>)</a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">[<span class="ex">jon@Snow</span>:~]$ ls Folder                                # Terug in Bash</a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="ex">File</span> File2 File2018 File3</a>
<a class="sourceLine" id="cb12-11" data-line-number="11"></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">[<span class="ex">jon@Snow</span>:~]$ jobs</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">[<span class="ex">1</span>]+  Stopped                 python3</a>
<a class="sourceLine" id="cb12-14" data-line-number="14"></a>
<a class="sourceLine" id="cb12-15" data-line-number="15">[<span class="ex">jon@Snow</span>:~]$ fg                                       # Terug in Python, waar we gebleven waren</a>
<a class="sourceLine" id="cb12-16" data-line-number="16"><span class="ex">python3</span>                                                # Bash vertelt nog welk proces er draait</a>
<a class="sourceLine" id="cb12-17" data-line-number="17"><span class="ex">print</span>(antwoord)                                        # <span class="ex">Geen</span> <span class="op">&gt;&gt;&gt;</span> (die staat hierboven al)</a>
<a class="sourceLine" id="cb12-18" data-line-number="18"><span class="ex">42</span></a>
<a class="sourceLine" id="cb12-19" data-line-number="19"><span class="op">&gt;&gt;&gt;</span>                                                    # <span class="ex">Na</span> een instructie wel weer <span class="op">&gt;&gt;&gt;</span></a>
<a class="sourceLine" id="cb12-20" data-line-number="20"></a>
<a class="sourceLine" id="cb12-21" data-line-number="21">[<span class="ex">jon@Snow</span>:~]$ du -chd1  <span class="op">&gt;</span> filesizes                    # Bereken grootte van elke subfolder</a>
<a class="sourceLine" id="cb12-22" data-line-number="22">^<span class="ex">Z</span>                                                     # Dit duurt te lang...</a>
<a class="sourceLine" id="cb12-23" data-line-number="23">[<span class="ex">1</span>]+  Stopped                 du -chd1 <span class="op">&gt;</span> filesizes     # Gepauzeerd</a>
<a class="sourceLine" id="cb12-24" data-line-number="24"></a>
<a class="sourceLine" id="cb12-25" data-line-number="25">[<span class="ex">jon@Snow</span>:~]$ bg                                       # Proces gaat op achtergrond door</a>
<a class="sourceLine" id="cb12-26" data-line-number="26">[<span class="ex">1</span>]+ du -chd1 <span class="op">&gt;</span> filesizes <span class="kw">&amp;</span></a>
<a class="sourceLine" id="cb12-27" data-line-number="27"></a>
<a class="sourceLine" id="cb12-28" data-line-number="28">[<span class="ex">jon@Snow</span>:~]$ jobs                                     # Running in joblist</a>
<a class="sourceLine" id="cb12-29" data-line-number="29">[<span class="ex">1</span>]+  Running                 du -chd1 <span class="op">&gt;</span> filesizes <span class="kw">&amp;</span>   # <span class="ex">Merk</span> op: er is een <span class="kw">&amp;</span> <span class="ex">toegevoegd</span></a>
<a class="sourceLine" id="cb12-30" data-line-number="30"></a>
<a class="sourceLine" id="cb12-31" data-line-number="31">[<span class="ex">jon@Snow</span>:~]$ disown</a>
<a class="sourceLine" id="cb12-32" data-line-number="32"></a>
<a class="sourceLine" id="cb12-33" data-line-number="33">[<span class="ex">jon@Snow</span>:~]$ jobs                                     # Geen uitvoer, job is onterfd</a>
<a class="sourceLine" id="cb12-34" data-line-number="34"></a>
<a class="sourceLine" id="cb12-35" data-line-number="35">[<span class="ex">jon@Snow</span>:~]$ du -chd1  <span class="op">&gt;</span> filesizes <span class="kw">&amp;</span>                  # <span class="ex">Met</span> <span class="kw">&amp;</span> <span class="ex">-</span><span class="op">&gt;</span> Start op achtergrond</a>
<a class="sourceLine" id="cb12-36" data-line-number="36">[<span class="ex">1</span>] 20251                                              # Job 1, PID 20251</a></code></pre></div>
<h1 id="werken-met-tekst">Werken met tekst</h1>
<p>We hebben inmiddels een aantal symbolen gezien met speciale betekenis in Bash. De hele lijst is de karakter <code># ' &quot; \ $ ` * ~ ? &lt; &gt; ( ) ! &amp; | ;</code>, spatie en enter. Wat nou als we deze karakters als karakter willen gebruiken, bijvoorbeeld omdat ze in een filename voorkomen? We kunnen de backslash gebruiken om een karakter te “escapen”: bash negeert de speciale betekenis. Een bestandsnaam met een spatie kan je bijvoorbeeld met <code>bestandsnaam\ met\ spatie</code> gebruiken (zonder spatie wordt dit als drie losse bestandsnamen beschouwd). Ook kunnen we quotes gebruiken; binnen enkele quotes wordt elk speciaal karakter genegeerd en als karakter gelezen. Bij dubbele quotes geldt dit alleen voor <code>$ ` \ ! *</code> en <code>@</code>. Ons eerste voorbeeld had dus ook bijvoorbeeld als <code>'bestandsnaam met spatie'</code> ingevoerd kunnen worden. Variabelen beginnen in Bash met een <code>$</code>. De variabele <code>$HOME</code> bevat bijvoorbeeld het pad van de home directory. Dubbele quotes escapen de meeste karakters, maar variabelen worden wel geëvalueerd. Het commando <code>echo</code> kan gebruikt worden om de waarde van een variabele te laten zien. <code>echo</code> geeft de invoer ongewijzigd terug, maar zal wel variabelen evalueren. <code>echo $HOME</code> (of <code>echo ~</code>) geeft bijvoorbeeld het pad van de home directory als uitvoer.</p>
<p>We hebben <code>less</code> gezien om een bestand te lezen. De uitvoer is echter interactief, wat het ongeschikt maakt om de uitvoer met een pipe door te sturen naar een ander programma. Hiervoor kunnen we <code>cat</code> gebruiken: dit leest een meegegeven bestand (of <code>STDIN</code>) en stuurt de inhoud naar <code>STDOUT</code>. Het lijkt hiermee een beetje op <code>echo</code>, maar er zijn belangrijke verschillen. <code>echo</code> zal zijn argument returnen, maar doet niets met <code>STDIN</code>. Probeer de commando’s op deze slide, en kijk wat het verschil is. Wat doet elke pipeline?</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~/Folder]$ echo  <span class="va">$HOME</span>             # Echo de inhoud van een variabele</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ex">/home/jon</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">[<span class="ex">jon@Snow</span>:~/Folder]$ echo <span class="st">&quot;Hallo Wereld&quot;</span>     # Echo een string</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="ex">Hallo</span> Wereld</a>
<a class="sourceLine" id="cb13-6" data-line-number="6"></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">[<span class="ex">jon@Snow</span>:~/Folder]$ cat                     # Interactieve echo</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="ex">Hallo</span> Wereld!                                # Dit typt de gebruiker</a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="ex">Hallo</span> Wereld!                                # Dit stuurt cat terug</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">^<span class="ex">D</span>                                           # Beeindig met Control-D</a>
<a class="sourceLine" id="cb13-11" data-line-number="11"></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">[<span class="ex">jon@Snow</span>:~/Folder]$ cat File2018            # Lees de inhoud van het bestand</a>
<a class="sourceLine" id="cb13-13" data-line-number="13"><span class="ex">Hallo</span> uit 2018!</a>
<a class="sourceLine" id="cb13-14" data-line-number="14"></a>
<a class="sourceLine" id="cb13-15" data-line-number="15">[<span class="ex">jon@Snow</span>:~/Folder]$ echo File2018           # Nu wordt de filename als string gezien</a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="ex">File2018</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17"></a>
<a class="sourceLine" id="cb13-18" data-line-number="18">[<span class="ex">jon@Snow</span>:~/Folder]$ echo File2018 <span class="kw">|</span> <span class="fu">cat</span>     # cat geeft het resultaat van echo door</a>
<a class="sourceLine" id="cb13-19" data-line-number="19"><span class="ex">File2018</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"></a>
<a class="sourceLine" id="cb13-21" data-line-number="21">[<span class="ex">jon@Snow</span>:~/Folder]$ echo File2018 <span class="kw">|</span> <span class="bu">echo</span>    # echo doet niets met invoer vanuit pipes</a></code></pre></div>
<h1 id="root-rechten">root-rechten</h1>
<div style="float:right; max-width:25vw; padding: 10px;">
<p><img style="max-width: 30vh;" src="https://peikos.net/V1EOS/Images/sudo.png"></p>
</div>
<p>Het kan voorkomen dat je probeert een proces te doden of een bestand of map te lezen, en dat Linux dit niet toe laat. Je hebt te maken met een rechtenprobleem. Meestal is dit op te lossen door tijdelijk root (super-user of in Windows termen “administrator”) rechten aan te vragen. Hiervoor zijn de commando’s <code>su</code> en <code>sudo</code>. De eerste geeft je doorgaans superuser rechten door een nieuwe shell als de root-gebruiker te openen, al kun je met <code>su -c</code> een enkel commando als root uitvoeren. <code>sudo</code> laat je standaard een enkel commando uitvoeren, maar dit mag ook een shell zijn met <code>sudo bash</code>. Beide kun je ook gebruiken om als een andere gebruiker dan root te werken: <code>sudo -u jon</code> en <code>su jon</code> geven je de rechten van Jon. Het belangrijke verschil in de werking is dat <code>su</code> het wachtwoord van de doelgebruiker verwacht: het root-wachtwoord voor gewoon <code>su</code> of Jon’s wachtwoord voor <code>su jon</code>. Bij <code>sudo</code> gebruik je je eigen wachtwoord, en wordt in een bestand gekeken of je het recht hebt om als de gekozen gebruiker te werken.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" data-line-number="1">[<span class="ex">jon@Snow</span>:~/Folder]$ ls RootFolder                         # Deze map is niet leesbaar</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="ex">ls</span>: cannot open directory <span class="st">&#39;RootFolder&#39;</span>: Permission denied</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">[<span class="ex">jon@Snow</span>:~/Folder]$ cd RootFolder                         # Maar mag wel geopend worden</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">[<span class="ex">jon@Snow</span>:~/Folder/RootFolder]$ ls</a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="ex">ls</span>: cannot open directory <span class="st">&#39;.&#39;</span>: Permission denied           # De inhoud is nog steeds onleesbaar</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">[<span class="ex">jon@Snow</span>:~/Folder/RootFolder]$ sudo ls                    # Met sudo als root proberen</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">[<span class="ex">sudo</span>] password for jon:                                   # Eigen wachtwoord</a>
<a class="sourceLine" id="cb14-11" data-line-number="11"><span class="ex">HiddenFile</span> HiddenFolder/                                   # De mapinhoud</a>
<a class="sourceLine" id="cb14-12" data-line-number="12"></a>
<a class="sourceLine" id="cb14-13" data-line-number="13">[<span class="ex">jon@Snow</span>:~/Folder/RootFolder]$ su -c ls                   # Met su als root proberen</a>
<a class="sourceLine" id="cb14-14" data-line-number="14"><span class="ex">Password</span>:                                                  # Wachtwoord van root</a>
<a class="sourceLine" id="cb14-15" data-line-number="15"><span class="ex">HiddenFile</span> HiddenFolder/</a>
<a class="sourceLine" id="cb14-16" data-line-number="16"></a>
<a class="sourceLine" id="cb14-17" data-line-number="17">[<span class="ex">jon@Snow</span>:~/Folder/RootFolder]$ sudo bash                  # Open een shell als root met sudo</a>
<a class="sourceLine" id="cb14-18" data-line-number="18"><span class="co"># Watchwoord niet opnieuw nodig voor aantal minuten</span></a>
<a class="sourceLine" id="cb14-19" data-line-number="19"></a>
<a class="sourceLine" id="cb14-20" data-line-number="20">[<span class="ex">root@Snow</span>:/home/jon/Folder/RootFolder]# ls                # ls in de root shell</a>
<a class="sourceLine" id="cb14-21" data-line-number="21"><span class="ex">HiddenFile</span> HiddenFolder/</a>
<a class="sourceLine" id="cb14-22" data-line-number="22"></a>
<a class="sourceLine" id="cb14-23" data-line-number="23">[<span class="ex">root@Snow</span>:/home/jon/Folder/RootFolder]# exit              # Terug naar de vorige shell</a>
<a class="sourceLine" id="cb14-24" data-line-number="24"></a>
<a class="sourceLine" id="cb14-25" data-line-number="25">[<span class="ex">jon@Snow</span>:~/Folder/RootFolder]$ su                         # Open een shell als root met su</a>
<a class="sourceLine" id="cb14-26" data-line-number="26"><span class="ex">Password</span>:                                                  # Wachtwoord (root) <span class="ex">wel</span> nodig</a>
<a class="sourceLine" id="cb14-27" data-line-number="27"></a>
<a class="sourceLine" id="cb14-28" data-line-number="28">[<span class="ex">root@Snow</span>:/home/jon/Folder/RootFolder]# ls                # ls in de root shell</a>
<a class="sourceLine" id="cb14-29" data-line-number="29"><span class="ex">HiddenFile</span> HiddenFolder/</a>
<a class="sourceLine" id="cb14-30" data-line-number="30"></a>
<a class="sourceLine" id="cb14-31" data-line-number="31">[<span class="ex">root@Snow</span>:/home/jon/Folder/RootFolder]# exit              # Terug naar de vorige shell</a></code></pre></div>
<h1 id="lifehacks">Lifehacks</h1>
<p>Lange commando’ of bestandsnamen kan Bash voor je aanvullen. Dit gebeurt met de Tab toets en heet tab-completion. <code>*</code> en <code>?</code> kunnen in een bestandsnaam gebruikt worden als soort van wildcards. <code>*</code> zal zoveel characters matchen als nodig is (inclusief 0): <code>File*.png</code> matcht bijvoorbeeld <code>File.png</code>, maar ook <code>FileFooBarUnicornLasers.png</code>. <code>?</code> werkt op eenzelfde manier, maar zal altijd exact één karakter matchen. Als je veel tussen dezelfde mappen heen en weer beweegt kan <code>cd -</code> niet meer voldoende zijn. In dit geval kan het handig zijn een stack (remember, les 0?) van paden te gebruiken. Je kunt <code>pushd</code> als alternatief voor <code>cd</code> gebruiken om meteen je huidige werkmap op een stack te zetten, en <code>popd</code> gebruiken om terug te keren naar de laatste map (het bovenste element van de stack). Het commando <code>dirs</code> toont de opgebouwde directory stack. Met de pijltjes naar boven en beneden kan je door je command-history lopen. Het vorige command nogmaals uitvoeren kan door een keer op pijltje naar boven te drukken, en dan op enter. <code>Control-p</code> en <code>Control-n</code> staan respectievelijk voor previous en next, en kunnen in plaats van boven en beneden gebruikt worden. <code>Control-r</code> staat je toe te zoeken in je command history, en met <code>history</code> kan je de history bekijken en eventueel entries verwijderen. Om een programma te stoppen kun je <code>Control-c</code> gebruiken, en in sommige gevallen <code>Control-d</code>. Die laatste stopt bijvoorbeeld je huidige shell. Waar <code>Control-c</code> als een letterlijk stop commando geïnterpreteerd wordt, is <code>Control-d</code> een end-of-file (EOF) karakter. Omdat je shell de interactie met de gebruiker als de <code>STDIN</code> file ziet, kun je deze met een EOF beëindigen en stopt de shell. <code>Control-z</code> stuurt een <code>SIGSTOP</code> en is ook handig om programma’s te onderbreken. Tot slot nog een paar toetsenbordcombinaties die als alternatief gebruikt kunnen worden voor toetsen die mogelijk verder weg zitten: <code>Control-a</code> is Home en <code>Control-e</code> is End. <code>Control-j</code> komt overeen met Enter. <code>Control-l</code> komt niet met een toets overeen, maar met het commando <code>clear</code>, voor als je de terminal leeg wil maken.</p>
</body>
</html>
